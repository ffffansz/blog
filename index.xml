<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Libre's Blog</title><link>https://blog.libre.fun/</link><description>Recent content on Libre's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>Libre. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Sun, 12 Apr 2020 02:55:32 +0800</lastBuildDate><atom:link href="https://blog.libre.fun/index.xml" rel="self" type="application/rss+xml"/><item><title>Hugo &amp; Github Pages 建站过程全记录</title><link>https://blog.libre.fun/posts/build-site-with-hugo-and-github-pages/</link><pubDate>Sun, 12 Apr 2020 02:55:32 +0800</pubDate><guid>https://blog.libre.fun/posts/build-site-with-hugo-and-github-pages/</guid><description>整体步骤 之前也使用Hugo搭建过几次个人博客，但是由于各种各样的问题始终不甚满意，未能持续运行。这次再从头搭建一次，力求将各种细节都做到让自己满意。
博客搭建的整体步骤如下：
从hugo new site建立的空项目开始，逐步添加内容。项目根路径记为Site
在项目目录下建立Git仓库，然后Push到Github，Github上对应的仓库名为blog
主题使用Git的子模块（Submodule）功能进行管理
修改主题时，不去修改主题子模块本身的文件，而是将对应的样式文件、HTML或JS文件SCSS或HTML文件复制到Site目录下对应的目录再进行修改。由于Hugo的样式查找策略，会使用Site下的样式文件去替代themes/&amp;lt;theme-name&amp;gt;下的样式文件。
这么做主要是考虑到主题后续还会更新，其样式文件会发生变化。Submodule功能可以指定子模块的某次commit作为主项目使用的版本，更新与否取决于主项目是否想要使用新的版本。
网站使用Github Pages发布，操作方式是在blog仓库中创建gh-pages分支，之后在仓库Setting页设置Source即可
使用自定义域名
利用Github Actions实现CI/CD，只需在本地master分支修改网站源码、添加博客内容，之后将master分支推送至Github即可，网站的生成和部署都由Github Actions完成。
接下来是对建站过程的一个记录，途中碰到的问题也会一并记录下来。
Git使用规范 之前使用Git的时候，自己有一个不好的习惯是修改一堆东西之后Commit一次，这样一来不但Commit Message不好写，而且版本管理也是一团糟，不利于版本回顾。
所以这次强迫自己，所有修改以功能点为单位，修改完一个点就Commit一次。
举个例子，假设我现在需要做两件事：(1) 修改文章标签的样式，(2) 修改Footer处的Copy Right。那么每做一件事，就Commit一次，并写清楚对应的Commit Message。
多说一句，Git的功能非常强大，使用得当可以节省大量的时间。Git入门我推荐廖雪峰的Git教程，浅显易懂。我个人对Git的掌握也非常粗浅，只能通过不断地实践来熟悉它了。
工具准备 本次搭建的是一个静态网站，使用的工具包括静态网站生成器Hugo、Git、Github Pages，以及一个基本的代码编辑器，推荐VSCode。使用的操作系统为Windows 10。
在Hugo - Github下载最新的Release，注意extended版本才支持SCSS样式文件；平台是Windows，所以这里选择下载hugo_extended_0.68.3_Windows-64bit.zip；解压后得到hugo.exe文件，在D盘下建立文件夹Hugo，将hugo.exe放入（即D:\Hugo\hugo.exe）。然后在「环境变量」→「系统变量」→Path中添加D:\Hugo，即可在终端（CMD、Powershell、VSCode Terminal）中使用hugo命令。 在Git Downloads中下载Windows版本的Git安装包，本文写作时的版本是2.26.0，有一大堆安装选项，之后有空的话我再写一篇文章专门解释各个选项的意思。#TODO Github Pages是Github推出的一项免费托管服务，可以根据Github仓库内的文件将其转换为可直接访问的网站，域名是&amp;lt;github-username&amp;gt;.github.io，也可以自定义域名。只需拥有一个Github账号即可使用该功能。 下文的所有命令，均在VSCode Terminal内执行（实质就是在VSCode内调用了Windows内置的Powershell）。
项目初始化 首先在Github上建立一个新仓库，名为blog，用于托管本次网站项目的源码。
接着在某个本地目录下操作，这里我选择了D盘根路径：
cd D:\ git clone https://github.com/ffffansz/blog.git Site 这样我们的Site文件夹在本地的绝对路径就是D:\Site。</description></item><item><title>WSL 设置开机启动项</title><link>https://blog.libre.fun/posts/setup-startup-in-wsl/</link><pubDate>Tue, 29 Oct 2019 14:30:09 +0800</pubDate><guid>https://blog.libre.fun/posts/setup-startup-in-wsl/</guid><description>在 WSL Ubuntu的安装和Troubleshooting 中，提到了WSL是一个阉割了部分功能的Linux，其中尤其是systemd的阉割，使得不能方便地通过systemctl enable &amp;lt;service_name&amp;gt;来把一个服务加入开机启动项内。
但是对于大部分使用WSL的人而言，无论是出于刚性需求（例如在WSL中运行一个Web服务器）、还是使用方便（随时通过SSH连接到WSL），都可能需要在WSL中加入开机启动项。具体方法如下所述。
本文阐述如何让一个WSL中的服务能够随Windows开机启动。以ssh服务为例，该服务在WSL Ubuntu 18.04 LTS发行版中自带，但安装好后不会开机启动。
在WSL中写好启动项脚本 echo -e &amp;#34;#! /bin/bash\n/etc/init.d/ssh start&amp;#34; | tee -a /etc/init.wsl chmod +x /etc/init.wsl echo &amp;#34;%sudo ALL=(ALL) NOPASSWD: /etc/init.wsl&amp;#34; | tee -a /etc/sudoers 上面的命令做了三件事：
在/etc目录下生成名为init.wsl的文件，并向其中写入以下两行内容：
#! /bin/bash /etc/init.d/ssh start 第一行向系统声明该脚本需要/bin/bash来执行，第二行则是执行ssh的启动脚本。
如果你有其他服务需要开机启动，使用vim编辑/etc/init.wsl，并将下面命令中的&amp;lt;service_name&amp;gt;替换成需要的服务名即可，该服务需要在/etc/init.d目录下存在：
/etc/init.d/&amp;lt;service_name&amp;gt; start 赋予/etc/init.wsl脚本可执行权限
在/etc/sudoers文件中声明：执行/etc/init.wsl脚本不需要输入密码
在Windows中添加开机启动脚本 由于WSL说到底还是Windows内置的一个“服务”，或者说是“组件”，因此对它的一些操作还是免不了要从Windows本身进行。
按下「Win + R」，输入shell:startup后回车，打开启动项文件夹。新建一个名为WhateverYouLike.vbs的文件，并使用记事本或者VSCode打开它，输入以下内容：
Set ws = CreateObject(&amp;quot;Wscript.Shell&amp;quot;) ws.run &amp;quot;bash -c &amp;quot;&amp;quot;sudo /etc/init.wsl&amp;quot;&amp;quot;&amp;quot;, vbhide 我对VB脚本语言不太了解，但是大概能理解这两句的含义。
第一句创建了一个可以执行命令的对象，命名为ws；第二句调用了该对象的run方法，执行了一句windows内的命令：</description></item><item><title>WSL 的安装和一些 Troubleshooting</title><link>https://blog.libre.fun/posts/install-wsl-and-troubleshooting/</link><pubDate>Tue, 29 Oct 2019 12:50:09 +0800</pubDate><guid>https://blog.libre.fun/posts/install-wsl-and-troubleshooting/</guid><description>什么是WSL WSL中文全称为「适用于 Linux 的 Windows 子系统」（Windows Subsystem for Linux），是一个为在Windows 10和Windows Server 2019上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。
WSL相比于VMware等虚拟机解决方案更加轻量，启动速度更快，但代价是阉割了一些Linux系统的功能，例如systemd、Ubuntu中的snapd等（截止本文写作时）。但是对于一般Linux用户的使用是足够的。
WSL的启用 在默认设置下，WSL是被关闭的，因此，首先需要在系统中开启WSL，有以下两种方式：
通过图形界面启用WSL Windows「设置」➡「应用」➡「程序和功能」➡「启用或关闭Windows功能」，勾选「适用于 Linux 的 Windows 子系统」
确定之后重启系统。
通过命令行启用WSL 右键单击「开始菜单」➡「Windows Powershell （管理员）」，打开Powershell后运行以下命令：
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 开始下载相关数据，下载完成后输入「yes」重启系统。
WSL的安装 在Windows中启用WSL之后，就可以安装你想使用的Linux发行版了，然而，这也要官方提供了相应的安装包才行。
安装WSL同样有两种方式，一种是通过Microsoft Store安装，另一种是下载相应的应用包之后手动安装。鉴于Microsoft Store在网络方面的表现非常不稳定，推荐手动安装。
手动安装👍 因为一些其他的原因，我之前就卸载了Microsoft Store，所以这里选择手动安装。根据官方文档，首先下载Ubuntu 18.04的Appx包，方便起见，将其重命名为ubuntu18.04.Appx：
假设下载好的包位于D:\Download文件夹下，打开Powershell，运行以下命令即可安装：
cd D:\Download Add-AppxPackage .\ubuntu18.04.Appx 通过Microsoft Store安装👎 进入Microsoft Store，搜索「Linux」，会出现官方提供的安装包，如下图所示（电脑上卸载了Microsoft Store，所以用网页版的截图代替一下）：
选择你想要的版本进行安装，我这里选择了Ubuntu 18.04 LTS。
WSL的运行 安装好之后就可以进入系统了，同样地，可以通过在CMD或则Powershell输入ubuntu1804.exe直接在当前窗口进入WSL Ubuntu，也可以在开始菜单中找到新添加的Ubuntu 18.04打开。
安装之后初次运行需要一些初始化的时间，需要等待一下。WSL默认有一个root用户，但初次运行通常会要求你添加一个新用户，按照提示输入用户名和密码即可，该用户会被自动成为sudoer。如遇到提示「Permission Denied」或需要以root身份运行某些命令时，在命令前加上sudo即可。
Troubleshooting WSL如何重启 参考：Rebooting Ubuntu on Windows without rebooting Windows?</description></item><item><title>Docker 入门：镜像</title><link>https://blog.libre.fun/posts/introduction-to-docker-image/</link><pubDate>Mon, 28 Oct 2019 10:58:00 +0800</pubDate><guid>https://blog.libre.fun/posts/introduction-to-docker-image/</guid><description>参考：Docker — 从入门到实践
镜像的基本原理 OS分为内核和用户空间。对于Linux而言，内核启动后， 会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。
Docker中的镜像利用Union FS技术，被设计为分层存储的架构，由多层文件系统联合组成。
镜像在构建时，会一层层构建，前一层是后一层的基础。 每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。
分层存储的特征使得镜像的复用、定制变的更为容易。可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
镜像仓库的相关概念 这里解释一下Docker镜像仓库相关的概念：
首先，读者应该知道Linux系统中有软件源的概念，一个软件源提供了若干软件的下载、安装与更新。例如，Ubuntu系统中通过apt install或者apt-get install命令从预先配置的软件源中下载和安装软件，CentOS也有类似的yum install等。
在Docker的世界中，这样的「软件源」被称为registry。registry用以保存Docker镜像，其中还包括镜像层次结构和关于镜像的元数据等。由Docker官方维护的registry被称为Docker Hub，用户也可以在自己的服务器上搭建私有的registry。
Docker Hub并不是只有Docker官方才可以提供镜像，它类似Github，任何用户都可以创建账号，向Docker Hub上传自己制作的镜像。
对于Docker Hub中存储的镜像，可以通过[username/]repository:tag来唯一指定。
如果不提供username，则会指向Docker官方维护的镜像库，即library；如果提供了username，则指向的是该用户的镜像库（相当于账户） repository表示的是具有某个功能的Docker镜像的所有迭代版本构成的镜像组，例如ubuntu，其含义是包括Ubuntu 18.04、Ubuntu 16.04、Ubuntu 14.04等一系列镜像在内的镜像组 tag用于指出repository中具体的某个镜像，例如ubuntu:latest，意为指定该镜像库中最新版的Ubuntu镜像；再例如ubuntu:16.04，意为指定版本号为16.04的Ubuntu镜像。 但是对于一条docker pull ubuntu命令来说，并不是拉取了整个镜像组，而是会使用一个默认的tag，即latest
不要混淆镜像库和镜像组的概念：
镜像库：默认为library或由username指定，是Docker官方或某用户提供的若干（不一定相关的）镜像组的集合；
镜像组：由repository，一般某个特定功能的镜像的若干迭代版本组成，每个迭代版本通常可以由一个标签指定，如上面举的ubuntu的例子；
因为library和repository在中文里都可以翻译为“库”，个人在看一些教程或书的时候也稍微混了一下，所以这里特意说明。
获取镜像 docker pull [options] [docker_registry_address[:port]/]repository[:tag] 其中：
docker_registry_address：Docker镜像仓库地址，格式一般为domain/IP[:port]。如果不给出，默认为Docker Hub repository：镜像名称，如ubuntu tag：指出镜像的版本，例如ubuntu:18.04，或者ubuntu:latest 例子：
$ docker pull ubuntu:18.</description></item><item><title>Ubuntu 18.04.3 各类代理配置</title><link>https://blog.libre.fun/posts/vmware-ubuntu-proxy-configure/</link><pubDate>Tue, 15 Oct 2019 16:54:57 +0800</pubDate><guid>https://blog.libre.fun/posts/vmware-ubuntu-proxy-configure/</guid><description>本文主要阐述在Ubuntu系统中为一些软件配置代理的方法，包括APT、Snap、Git、Bash命令行以及Ubuntu系统层面的HTTP代理。
准备工作 实验环境 本文中，笔者在VMware虚拟机中安装了Ubuntu系统，网络连接使用NAT模式。就代理的配置方式而言，无论虚拟机还是物理机都是通用的，区别只在于代理IP有所不同。在物理机上配置代理，只需要知道代理软件的IP（记作PROXY_IP）和端口（本文中默认使用1080）。
虚拟机使用NAT模式连接网络 如果你是在虚拟机中安装了Ubuntu系统，则需要确认其网络访问方式为NAT。打开VMware，右键点击左侧「库」面板中安装好的虚拟机，进入「网络适配器」查看网络连接模式，将其设置为「NAT模式」，如下图所示
代理工具的准备 由于众所周知的原因，必须借助某些代理软件才能够实现对外网的流畅访问。
在SS或者SSR中，需要打开“允许来自局域网的连接”(SSR-windows 4.9.2)或者“允许其他设备连入”(SS-windows 4.1.7)等类似的选项。该选项的名称可能会根据代理软件版本的不同而有细微的差别。
在宿主机上安装XShell （可选） XShell是一个用于SSH连接到主机的工具，这里推荐安装和使用。如果没有使用过这类工具的用户可以略过。
确认代理IP地址 在虚拟机方案中，通常是宿主机上运行代理软件，然后配置虚拟机Ubuntu系统的代理，从而使Ubuntu正常访问外网。此时则需要查看宿主机的IP地址。
以Windows为例，按下「Win+R」，输入cmd并按下回车，打开Windows命令提示符。
输入ipconfig，在「以太网适配器 VMware Network Adapter VMnet8」中查看IPv4地址，通常以172.16/17/18或者192.168开头。
VMware Network Adapter VMnet8 是VMware中使用NAT模式的虚拟机专用的网络适配器。
将该IP地址记为PROXY_IP，即我们需要的代理IP地址。后文中将始终使用PROXY_IP。读者在实践时需要替换为自己查看到的IP地址。
确认代理端口号 一般来讲，如果没有做过更改，SS和SSR使用的代理端口号都是1080。所以本文的命令中都会使用1080这个端口号。
确认系统权限 本文中使用的部分命令需要root权限，如果在root账户下，则可以直接执行命令；如果是在普通账户下，需要在命令前加上sudo关键字。
APT代理配置 参考：How to Set the Proxy for APT on Ubuntu 18.04
APT是Ubuntu系统内常用的软件包管理器，为APT配置代理之后能够保证一些软件可以正常安装，安装速度通常也会有一定的提升。
给APT配置代理的步骤如下：
$ sudo apt install vim # 该命令是为了安装Vim编辑器，Ubuntu不自带Vim；如果已安装，则可以忽略这一条 $ sudo vim /etc/apt/apt.conf.d/proxy.conf # 此时会创建并打开一个名为proxy.conf的文件，按下I进入编辑模式，输入以下几行 Acquire { HTTP::proxy &amp;#34;http://PROXY_IP:1080&amp;#34;; HTTPS::proxy &amp;#34;http://PROXY_IP:1080&amp;#34;; } # 输入后按下Esc，然后输入:wq，按下回车即可保存退出 打开代理软件（SS或者SSR）的流量监控，使用apt-get install命令安装任意一个包，查看下载速度并和宿主机上的流量监控数据进行对照，如果速度接近，即说明代理配置成功。</description></item><item><title>CentOS 7.6 Minimal Installation 后无法连接网络</title><link>https://blog.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/</link><pubDate>Sat, 05 Oct 2019 12:53:00 +0800</pubDate><guid>https://blog.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/</guid><description>问题原因 在安装CentOS 7.6系统时，图形安装界面的部分有一个配置网络的选项，进去之后可以开启网卡，而Minimal Installation默认是不开启网卡的，因此如果在安装系统时由于疏忽忘记打开网卡，进入系统之后会发现无法联网，所有和网络有关的操作都会报错。
解决方法 首先通过命令nmcli d查看网卡启用状态：
[libre@localhost ~]$ nmcli d DEVICE TYPE STATE CONNECTION ens33 ethernet disconnected -- lo loopback unmanaged -- 发现网卡的确是未启用。然后编辑文件/etc/sysconfig/network-scripts/ifcfg-ens&amp;lt;num&amp;gt;，此处的&amp;lt;num&amp;gt;在每台机器可能不一样，使用Tab自动补全即可。
将该文件最后一行的ONBOOT=NO改为ONBOOT=YES，然后保存退出，再通过以下命令重启网络：
service network restart 此时再查看网卡状态：
[libre@localhost ~]$ nmcli d DEVICE TYPE STATE CONNECTION ens33 ethernet connected ens33 lo loopback unmanaged -- 搞定。</description></item><item><title>关于</title><link>https://blog.libre.fun/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.libre.fun/about/</guid><description>欢迎来到Libre的个人博客。
应当向你简单地介绍一下我自己：我来自西北，成长在黄土高原上。1997年生人，八月份的狮子座，外向，热情，有一些争强好胜，也有一丝怯懦。
关于教育 本科就读于广州中山大学，2019年6月毕业。目前在中山大学攻读软件工程专业硕士，2019年8月入学，顺利的话，大概会在2021年的6月拿到学位证书。
目前的研究方向是虚拟化技术在高性能计算领域（HPC）的应用，其中，虚拟化技术包括硬件虚拟化和操作系统虚拟化。听起来很高大上，但自己目前也只是了解皮毛中的皮毛，学海无涯。
关于工作 我想成为一个从事后端开发的软件工程师。
我有中重度的完美主义和强迫症。拿搭博客这件事举例子，于一些人可能是一个记录技术文章的地方，于我则像一件需要细细打磨的手工艺品。选中一个Hugo主题之后（千挑万选才确定主题的过程就不说了），会把主题中的每个细节都修改到自己想要的样子——改HTML，改CSS，改JS，等等。会阅读主题的源码，搞清楚每一行在做什么，有没有哪处是多余的可以删去。遇到不会的就查阅Hugo的官方文档，直到搞清楚每一句代码的功能。当然，我也清楚，博客最重要的是内容，具体的我在下一节会聊到。
前端技术日新月异，时不时会看到有人吐槽新框架、新功能「慢点出」「学不动了」之类的。我想以我这样的性格去搞前端可能会把自己饿死，因为对旧框架的技术执念还没放下，新的框架就已经出来了。
以我浅薄的见识，后端技术也许更适合我。后端是一切互联网服务的基石，也需要日复一日的精钻细研。
这些都是我还作为一个学生对于职业的简单展望，我的技能树也暂时会朝着这个方向尽量去发展，希望自己能够日上一层。
关于博客 技术很重要，但写作对我而言更重要。本科阶段我还保持着写作的习惯，会在自己的公众号上隔三差五写一点胡思乱想、无病呻吟的文字，操弄词句会给我带来精神上的愉悦和满足。但那些很多是感性文字，与我所学专业关联的技术文章——简洁明了、力求精准的理性文字——有天壤之别。因此在技术文章的写作上，我还很不熟练，甚至有时候会只有操作步骤的简单堆砌。
因此希望来到这里的你可以不吝指教，尽情发表你对文章的看法。在技术上，我会力求详细清晰，在行文上，我也会努力做到精简流畅，甚至试图让技术文章脱离说明文那种冰冷的语调和展开，让文章更有情味一些。这是我努力的目标。
 感谢你耐心的阅读。「关于」这个页面可以说是一份结合了经历、自白、成就的啰里巴嗦的「简历」。我会不断地去完善它、充实它，也当做是对自己成长的记录。
如果你有任何想法打算与我交流、讨论，可以通过邮箱：branchvan379@gmail.com 来联系我，我会尽快回复。
祝你生活愉快。</description></item></channel></rss>