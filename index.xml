<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Libre's Blog</title><link>https://www.libre.fun/</link><description>Recent content on Libre's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>Libre. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Sun, 12 Apr 2020 02:55:32 +0800</lastBuildDate><atom:link href="https://www.libre.fun/index.xml" rel="self" type="application/rss+xml"/><item><title>Hugo &amp; Github Pages 建站过程全记录</title><link>https://www.libre.fun/posts/build-site-with-hugo-and-github-pages/</link><pubDate>Sun, 12 Apr 2020 02:55:32 +0800</pubDate><guid>https://www.libre.fun/posts/build-site-with-hugo-and-github-pages/</guid><description>Libre's Blog https://www.libre.fun/posts/build-site-with-hugo-and-github-pages/ -&lt;h2 id="整体步骤">整体步骤&lt;/h2>
&lt;p>之前也使用Hugo搭建过几次个人博客，但是由于各种各样的问题始终不甚满意，未能持续运行。这次再从头搭建一次，力求将各种细节都做到让自己满意。&lt;/p>
&lt;p>博客搭建的整体步骤如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从&lt;code>hugo new site&lt;/code>建立的空项目开始，逐步添加内容。项目根路径记为&lt;code>Site&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在项目目录下建立Git仓库，然后Push到Github，Github上对应的仓库名为&lt;code>blog&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主题使用Git的子模块（Submodule）功能进行管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改主题时，不去修改主题子模块本身的文件，而是将对应的样式文件、HTML或JS文件SCSS或HTML文件复制到&lt;code>Site&lt;/code>目录下对应的目录再进行修改。由于Hugo的样式查找策略，会使用&lt;code>Site&lt;/code>下的样式文件去替代&lt;code>themes/&amp;lt;theme-name&amp;gt;&lt;/code>下的样式文件。&lt;/p>
&lt;blockquote>
&lt;p>这么做主要是考虑到主题后续还会更新，其样式文件会发生变化。Submodule功能可以指定子模块的某次commit作为主项目使用的版本，更新与否取决于主项目是否想要使用新的版本。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>网站使用Github Pages发布，操作方式是在&lt;code>blog&lt;/code>仓库中创建&lt;code>gh-pages&lt;/code>分支，之后在仓库Setting页设置Source即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用自定义域名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>利用Github Actions实现CI/CD，只需在本地&lt;code>master&lt;/code>分支修改网站源码、添加博客内容，之后将&lt;code>master&lt;/code>分支推送至Github即可，网站的生成和部署都由Github Actions完成。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>接下来是对建站过程的一个记录，途中碰到的问题也会一并记录下来。&lt;/p>
&lt;h2 id="git使用规范">Git使用规范&lt;/h2>
&lt;p>之前使用Git的时候，自己有一个不好的习惯是修改一堆东西之后Commit一次，这样一来不但Commit Message不好写，而且版本管理也是一团糟，不利于版本回顾。&lt;/p>
&lt;p>所以这次强迫自己，&lt;strong>所有修改以功能点为单位，修改完一个点就Commit一次。&lt;/strong>&lt;/p>
&lt;p>举个例子，假设我现在需要做两件事：(1) 修改文章标签的样式，(2) 修改Footer处的Copy Right。那么每做一件事，就Commit一次，并写清楚对应的Commit Message。&lt;/p>
&lt;p>多说一句，Git的功能非常强大，使用得当可以节省大量的时间。Git入门我推荐&lt;a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程&lt;/a>，浅显易懂。我个人对Git的掌握也非常粗浅，只能通过不断地实践来熟悉它了。&lt;/p>
&lt;h2 id="工具准备">工具准备&lt;/h2>
&lt;p>本次搭建的是一个静态网站，使用的工具包括静态网站生成器Hugo、Git、Github Pages，以及一个基本的代码编辑器，推荐VSCode。使用的操作系统为Windows 10。&lt;/p>
&lt;ol>
&lt;li>在&lt;a href="https://github.com/gohugoio/hugo/releases">Hugo - Github&lt;/a>下载最新的Release，注意extended版本才支持SCSS样式文件；平台是Windows，所以这里选择下载&lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.68.3/hugo_extended_0.68.3_Windows-64bit.zip">hugo_extended_0.68.3_Windows-64bit.zip&lt;/a>；解压后得到&lt;code>hugo.exe&lt;/code>文件，在D盘下建立文件夹&lt;code>Hugo&lt;/code>，将&lt;code>hugo.exe&lt;/code>放入（即&lt;code>D:\Hugo\hugo.exe&lt;/code>）。然后在「环境变量」→「系统变量」→&lt;code>Path&lt;/code>中添加&lt;code>D:\Hugo&lt;/code>，即可在终端（CMD、Powershell、VSCode Terminal）中使用&lt;code>hugo&lt;/code>命令。&lt;/li>
&lt;li>在&lt;a href="https://git-scm.com/downloads">Git Downloads&lt;/a>中下载Windows版本的Git安装包，本文写作时的版本是2.26.0，有一大堆安装选项，之后有空的话我再写一篇文章专门解释各个选项的意思。#TODO&lt;/li>
&lt;li>Github Pages是Github推出的一项免费托管服务，可以根据Github仓库内的文件将其转换为可直接访问的网站，域名是&lt;code>&amp;lt;github-username&amp;gt;.github.io&lt;/code>，也可以自定义域名。只需拥有一个Github账号即可使用该功能。&lt;/li>
&lt;/ol>
&lt;p>下文的所有命令，均在VSCode Terminal内执行（实质就是在VSCode内调用了Windows内置的Powershell）。&lt;/p>
&lt;h2 id="项目初始化">项目初始化&lt;/h2>
&lt;p>首先在Github上建立一个新仓库，名为&lt;code>blog&lt;/code>，用于托管本次网站项目的源码。&lt;/p>
&lt;p>接着在某个本地目录下操作，这里我选择了D盘根路径：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">cd D:\
git clone https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//github.com/ffffansz/blog.git Site
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样我们的&lt;code>Site&lt;/code>文件夹在本地的绝对路径就是&lt;code>D:\Site&lt;/code>。&lt;/p>
&lt;p>在&lt;code>Site&lt;/code>下添加&lt;code>README.md&lt;/code>文件，简述该仓库的用途：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#75715e"># Blog&lt;/span>
My personal site, powered by &lt;span style="color:#66d9ef">[Hugo]&lt;/span>(https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//gohugo.io) &amp;amp; [hugo-theme-diary](https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//github.com/AmazingRise/hugo-theme-diary).
Hosted on Github Pages &lt;span style="color:#66d9ef">for&lt;/span> now.
Welcome to visit it! &lt;span style="color:#960050;background-color:#1e0010">😊&lt;/span>
&lt;span style="color:#66d9ef">[Libre]&lt;/span>(https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//libre.fun)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在&lt;code>D:\Site\&lt;/code>目录下使用Hugo命令创建新站点：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">cd D:\Site
hugo new site .
&lt;/code>&lt;/pre>&lt;/div>&lt;p>会发现&lt;code>Site&lt;/code>目录内生成了如下的项目结构：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#960050;background-color:#1e0010">├─&lt;/span>archetypes
&lt;span style="color:#960050;background-color:#1e0010">├─&lt;/span>content
&lt;span style="color:#960050;background-color:#1e0010">├─&lt;/span>data
&lt;span style="color:#960050;background-color:#1e0010">├─&lt;/span>layouts
&lt;span style="color:#960050;background-color:#1e0010">├─&lt;/span>static
&lt;span style="color:#960050;background-color:#1e0010">└─&lt;/span>themes
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用Git命令提交项目的更改，并推送到Github：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">cd D:\Site
git add .
git commit -m &lt;span style="color:#e6db74">&amp;#34;first commit&amp;#34;&lt;/span>
git push -u origin master
&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此，初始化工作就完成了。&lt;/p>
&lt;h2 id="添加主题">添加主题&lt;/h2>
&lt;p>接下来利用Git Submodule功能添加主题。&lt;/p>
&lt;p>Git Submodule简单来讲，就是在一个Git仓库中嵌套另一个Git仓库。以本网站为例，&lt;code>D:\Site&lt;/code>是一个Git仓库，而即将要添加的主题通常也是一个Git仓库，二者是嵌套关系。在Git的文档中，主仓库被称为SuperProject，本文中指的就是网站项目本身，主题则作为一个Submodule，可在SuperProject中使用&lt;code>git submodule&lt;/code>命令统一管理。&lt;/p>
&lt;blockquote>
&lt;p>当然，也可以直接下载主题文件并放进&lt;code>Site/themes&lt;/code>目录下。但是Hugo官方推荐以Submodule来管理主题。个人认为这样做的好处是方便主题的更新。&lt;/p>
&lt;/blockquote>
&lt;p>首先我们在&lt;a href="https://themes.gohugo.io/">Hugo Theme&lt;/a>挑选一个中意的主题，这里我选择了&lt;a href="https://github.com/AmazingRise/hugo-theme-diary">hugo-theme-diary&lt;/a>。&lt;/p>
&lt;p>使用&lt;code>git submodule&lt;/code>命令将其添加为主题，并更新：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">cd D:\Site
git submodule add https&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//github.com/AmazingRise/hugo-theme-diary.git themes/diary
git submodule update --init --remote
&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成后提交更改：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">git add .
git commit -m &lt;span style="color:#e6db74">&amp;#34;add submodule themes/diary&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="添加内容">添加内容&lt;/h2>
&lt;p>在Hugo中，所有的内容文件都放在&lt;code>content&lt;/code>目录下。对于个人博客，一般的做法是，在&lt;code>content&lt;/code>下建立&lt;code>posts&lt;/code>文件夹，然后往内放入博客文章的Markdown文件。&lt;/p>
&lt;p>这里需要说明，不同主题对于内容文件放置的方式可能有不同的规定，对于本文使用的&lt;code>diary&lt;/code>主题以及大部分Hugo主题来说，上面提到的方式就是符合规范的。其他主题适用的放置方式则可以参考主题本身的说明或是主题源码下的&lt;code>exampleSite/content&lt;/code>目录。&lt;/p>
&lt;h2 id="主题定制与本地预览">主题定制与本地预览&lt;/h2>
&lt;p>接下来对网站主题进行定制，将其修改为自己喜欢的样式。&lt;/p>
&lt;blockquote>
&lt;p>不同主题的样式文件组织不同，因此这一部分并不适用于所有主题。&lt;/p>
&lt;/blockquote>
&lt;p>对主题进行定制有两种方式：&lt;/p>
&lt;ol>
&lt;li>一种是按照主题作者给出的设置项，修改网站根目录下&lt;code>config.toml&lt;/code>中的参数项，进行简单的功能配置。此项一般能够满足大部分人对网站主题的需求。&lt;/li>
&lt;li>直接对CSS/SCSS样式文件、HTML模板和JS脚本进行修改。此项要求对Hugo模板（Template）和Web前端有了解。Hugo模板的技术细节需要阅读Hugo的&lt;a href="https://gohugo.io/documentation/">官方文档&lt;/a>，CSS/SCSS、JS则可以在网上找一些教程进行入门。&lt;/li>
&lt;/ol>
&lt;h3 id="预览主题示例网站">预览主题示例网站&lt;/h3>
&lt;p>这里我们首先对主题进行预览。所有的Hugo主题都有一个&lt;code>exampleSite&lt;/code>文件夹，在本项目中，该文件夹的路径为&lt;code>D:\Site\themes\diary\exampleSite&lt;/code>。通过以下命令，使用Hugo构建网站并启动本地服务器：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">cd D:\Site\themes\diary\exampleSite
hugo server --themesDir ../..
&lt;span style="color:#75715e"># 以下为命令输出：&lt;/span>
Building sites &lt;span style="color:#960050;background-color:#1e0010">…&lt;/span>
| EN
-------------------+-----
Pages | 31
Paginator pages | 0
Non-page files | 0
Static files | 20
Processed images | 0
Aliases | 13
Sitemaps | 1
Cleaned | 0
Built &lt;span style="color:#66d9ef">in&lt;/span> 48 ms
Watching &lt;span style="color:#66d9ef">for&lt;/span> changes &lt;span style="color:#66d9ef">in&lt;/span> D:\Blog\Site\themes\diary\{archetypes,assets,exampleSite,layouts,static}
Watching &lt;span style="color:#66d9ef">for&lt;/span> config changes &lt;span style="color:#66d9ef">in&lt;/span> D:\Blog\Site\themes\diary\exampleSite\config.toml
Environment&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;development&amp;#34;&lt;/span>
Serving pages from memory
Running &lt;span style="color:#66d9ef">in&lt;/span> Fast Render Mode. &lt;span style="color:#66d9ef">For&lt;/span> full rebuilds on change&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> hugo server --disableFastRender
Web Server is available at http&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>//localhost&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>1313/ (bind address 127.0.0.1)
Press Ctrl+C to stop
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到网站已经运行在了&lt;code>localhost:1313&lt;/code>上，打开浏览器输入&lt;code>localhost:1313&lt;/code>即可看到本地运行的网站。&lt;/p>
&lt;blockquote>
&lt;p>注意，此时预览的是由主题作者提供的示例网站，配置文件使用了&lt;code>exampleSite\config.toml&lt;/code>，内容文件使用了&lt;code>exampleSite\content&lt;/code>。当你为自己的网站添加了内容和配置文件后，则需要在网站的根目录下执行&lt;code>hugo server&lt;/code>命令。&lt;/p>
&lt;/blockquote>
&lt;h3 id="主题定制">主题定制&lt;/h3>
&lt;p>由于这部分并不通用，所以我只会简单记载所做的修改。&lt;a href="https://github.com/AmazingRise/hugo-theme-diary">hugo-theme-diary&lt;/a>可在&lt;code>config.toml&lt;/code>中配置一些基本功能模块，教程位于其Github仓库的Wiki中。&lt;/p>
&lt;p>从初始化仓库到写作本文时，我总共进行了42次Commit，主要内容会写在网站的&lt;a href="https://github.com/ffffansz/blog/blob/master/CHANGELOG.md">CHANGELOG&lt;/a>中。&lt;/p>
&lt;h2 id="发布到github-pages">发布到Github Pages&lt;/h2>
&lt;p>Github Pages是Github提供的免费静态网站托管服务。如果你的网站访问量较低，且没有其他服务器方面的需求，那么利用Github Pages来建立一个自己的个人网站是非常合适的选择。&lt;/p>
&lt;p>以前，Github Pages还要求仓库名必须为&lt;code>&amp;lt;username&amp;gt;.github.io&lt;/code>的形式，不知道什么时候起就取消了这项规定，任何仓库名都可以被用来创建Github Pages。&lt;/p>
&lt;p>正常情况下，在本地完成对网站内容或样式的编辑后，在&lt;code>Site&lt;/code>路径下执行&lt;code>hugo&lt;/code>命令，会生成&lt;code>Site/public&lt;/code>目录，该目录就是你的网站文件。然后使用&lt;code>git commit&lt;/code>和&lt;code>git push&lt;/code>命令，即可将网站源码和网站文件一起推送到Github仓库的master分支下。&lt;/p>
&lt;p>但是这个方式，着实不太优雅，不但每次都需要手工构建网站（执行&lt;code>hugo&lt;/code>命令），而且源码还和编译结果搅和在一起。况且，Github Pages仅支持仓库根目录下以&lt;code>docs&lt;/code>命名的目录作为发布目录，Hugo生成的&lt;code>public&lt;/code>目录还需改名才能使用，更是麻烦。&lt;/p>
&lt;p>因此这里我们借助Github Actions的功能，在master分支push后自动构建网站，并将构建结果（&lt;code>public&lt;/code>目录）发布到单独的&lt;code>gh-pages&lt;/code>分支。随后我们只需在仓库的Setting页面设置Github Pages使用&lt;code>gh-pages&lt;/code>分支来作为发布源即可，如下图：&lt;/p>
&lt;p>&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20200412000129.png" alt="">&lt;/p>
&lt;h3 id="cicd-workflow">CI/CD Workflow&lt;/h3>
&lt;p>上文所述的这类自动构建、部署的流程也被称为CI/CD。Github Actions就正好可以完成这一工作。&lt;/p>
&lt;p>前文提到，一旦Github Pages发布成功，网站即可通过&lt;code>&amp;lt;username&amp;gt;.github.io&lt;/code>来访问。因此，在制作CI/CD工作流前，我们首先需要在&lt;code>config.toml&lt;/code>内修改&lt;code>baseURL&lt;/code>的值：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">&lt;span style="color:#a6e22e">baseURL&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;https://&amp;lt;username&amp;gt;.github.io/&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># 需要将&amp;lt;username&amp;gt;替换成你自己的Github账户名&lt;/span>
&lt;span style="color:#75715e"># other params ...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来才是利用Github Actions建立CI/CD工作流的过程。&lt;/p>
&lt;p>首先需要在&lt;code>Site&lt;/code>目录下建立&lt;code>.github/workflows/&lt;/code>目录，然后在&lt;code>workflows&lt;/code>目录下建立一个&lt;code>gh-pages.yml&lt;/code>的文件。&lt;/p>
&lt;blockquote class="my-alert my-alert-warning">
&lt;p>&lt;p>不要忽略&lt;code>.github&lt;/code>前面的&lt;code>.&lt;/code>；&lt;/p>
&lt;p>&lt;code>gh-pages.yml&lt;/code>的路径为&lt;code>Site/.github/workflows/gh-pages.yml&lt;/code>&lt;/p>
&lt;/p>
&lt;/blockquote>
&lt;p>然后在&lt;code>gh-pages.yml&lt;/code>中写入如下内容（基于写作时最新版&lt;a href="https://github.com/peaceiris/actions-gh-pages">actions-gh-pages&lt;/a>的Hugo示例修改而来）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#66d9ef">name&lt;/span>: Github Pages Deploy
&lt;span style="color:#66d9ef">on&lt;/span>:
&lt;span style="color:#66d9ef">push&lt;/span>:
&lt;span style="color:#66d9ef">branches&lt;/span>:
- master
&lt;span style="color:#66d9ef">jobs&lt;/span>:
&lt;span style="color:#66d9ef">deploy&lt;/span>:
&lt;span style="color:#66d9ef">runs-on&lt;/span>: ubuntu&lt;span style="color:#ae81ff">-18.04&lt;/span>
&lt;span style="color:#66d9ef">steps&lt;/span>:
- &lt;span style="color:#66d9ef">uses&lt;/span>: actions/checkout@v2
&lt;span style="color:#66d9ef">with&lt;/span>:
&lt;span style="color:#66d9ef">submodules&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># Fetch submodule Hugo themes&lt;/span>
&lt;span style="color:#66d9ef">fetch-depth&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Fetch all commit history for .GitInfo and .Lastmod&lt;/span>
- &lt;span style="color:#66d9ef">name&lt;/span>: Setup Hugo
&lt;span style="color:#66d9ef">uses&lt;/span>: peaceiris/actions-hugo@v2
&lt;span style="color:#66d9ef">with&lt;/span>:
&lt;span style="color:#66d9ef">hugo-version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;0.68.3&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">extended&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
- &lt;span style="color:#66d9ef">name&lt;/span>: Build
&lt;span style="color:#66d9ef">run&lt;/span>: hugo --minify
- &lt;span style="color:#66d9ef">name&lt;/span>: Deploy
&lt;span style="color:#66d9ef">uses&lt;/span>: peaceiris/actions-gh-pages@v3
&lt;span style="color:#66d9ef">with&lt;/span>:
&lt;span style="color:#66d9ef">github_token&lt;/span>: ${{ secrets.GITHUB_TOKEN }}
&lt;span style="color:#66d9ef">publish_dir&lt;/span>: ./public
&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成后，Commit并Push到Github，然后去Setting页面，将Github Pages的Source设置为&lt;code>gh-pages&lt;/code>即可。&lt;/p>
&lt;p>Push后在仓库主页确认你的Actions执行状态：&lt;/p>
&lt;p>&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20200412002223.png" alt="">&lt;/p>
&lt;p>黄色圆点表示正在执行或排队等待，&lt;strong>绿色对勾表示执行完成&lt;/strong>，红色叉则表示构建出错，需要手动查看一下出错原因。个别时候是因为玄学问题，Re-Run一下即可，大部分时候还是网站源码本身存在错误，建议在本地执行&lt;code>hugo&lt;/code>排查错误。&lt;/p>
&lt;p>如果一切顺利，等待几分钟，访问&lt;code>&amp;lt;username&amp;gt;.github.io&lt;/code>就能看到你的个人网站了。&lt;/p>
&lt;h2 id="自定义域名及https">自定义域名及HTTPS&lt;/h2>
&lt;p>最后，个人网站怎么能没有一个具有个人特色的域名呢。当你拥有自己的域名之后，就可以将其用在由Github Pages托管的个人网站上。&lt;/p>
&lt;p>首先我们来明确最终要达到的效果。我拥有&lt;code>libre.fun&lt;/code>这个域名，想将其作为我个人主页的域名。并且，无论是输入&lt;code>www.libre.fun&lt;/code>还是&lt;code>libre.fun&lt;/code>都能正常访问网站。最后，出于安全和浏览器兼容性考虑，为网站设置HTTPS。&lt;/p>
&lt;blockquote>
&lt;p>主流浏览器目前都会给HTTP网站打上“不安全”的标记，例如Chrome。&lt;/p>
&lt;/blockquote>
&lt;p>设置的时候我也参考了网上不少的中文博客，但是很少有能把自定义域名这个过程讲清楚的，所以最后直接参照了Github Pages官方的帮助文档。&lt;/p>
&lt;p>要实现上面所说的效果，需要进行以下几个步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在&lt;code>config.toml&lt;/code>中修改&lt;code>baseURL&lt;/code>，这里我们改为带&lt;code>www&lt;/code>前缀的&lt;code>https://www.libre.fun/&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在DNS提供商处添加解析记录。这一步最不容易理解，我们一步一步来讲。&lt;/p>
&lt;p>以我的域名&lt;code>libre.fun&lt;/code>为例，我是在Namecheap购买的，然后购买了腾讯云DNSPod个人专业版云解析服务来进行DNS解析。&lt;/p>
&lt;p>首先，按照DNSPod的提示，在Namecheap上修改&lt;code>libre.fun&lt;/code>的DNS：&lt;/p>
&lt;p>&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20200412021814.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>如果是其他DNS解析服务，DNS地址可能会有所不同。DNSPod免费版、个人专业版的DNS地址也会不同。具体以DNS服务提供商给出的提示为准。&lt;/p>
&lt;p>多说一句，DNSPod个人专业版经常会有促销活动，6元/年，非常划算。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20200412021901.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>在域名注册商处修改完成后，通常需要等待一段时间，DNS服务提供商那里才会显示解析正常。&lt;/p>
&lt;/blockquote>
&lt;p>等到DNSPod显示解析正常后，在解析管理处，添加如下的解析记录：&lt;/p>
&lt;p>&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20200412022410.png" alt="">&lt;/p>
&lt;p>可以看到，图中总共有五个解析记录，四个A类型，一个CNAME类型。那么这些记录都是什么意思呢？&lt;/p>
&lt;p>简单来说，&lt;strong>四个主机记录为@的A类型记录&lt;/strong>，是将&lt;code>libre.fun&lt;/code>这个地址解析到了四个不同的IP地址上，而这四个IP地址，都是Github Pages提供服务的IP地址，其出处是Github Pages的官方文档：&lt;a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site">Managing a custom domain for your GitHub Pages site&lt;/a>。&lt;/p>
&lt;p>而主机记录为www的CNAME记录，则是将&lt;code>www.libre.fun&lt;/code>指向了&lt;code>ffffansz.github.io&lt;/code>这个默认域名，再由&lt;code>ffffansz.github.io&lt;/code>来提供IP地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在&lt;code>blog&lt;/code>仓库的Setting页，将Github Pages的Custom Domain设置为&lt;code>www.libre.fun&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>一定要是带www前缀的，否则会出现问题。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>等待一小会后，勾选「Enforce HTTPS」。&lt;/p>
&lt;p>&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20200412023430.png" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>如果你严格按照上述步骤操作，没有在哪里该添加、哪里不该添加&lt;code>www&lt;/code>前缀的问题上出错，那么几分钟后，无论是带还是不带&lt;code>www&lt;/code>的个人域名，都可以用来访问你的个人主页了。&lt;/p>
&lt;p>注意，如果没有按照上述步骤操作，你可能会遇到以下问题中的某个或多个：&lt;/p>
&lt;ul>
&lt;li>&lt;code>libre.fun&lt;/code>或&lt;code>www.libre.fun&lt;/code>其中一个地址打开会出现404&lt;/li>
&lt;li>进入网站后发现网页只有文字和链接，网页样式丢失，按下F12，Console的报错信息与CORS相关：
&lt;ul>
&lt;li>可能是&lt;code>libre.fun&lt;/code>和&lt;code>www.libre.fun&lt;/code>之间的CORS问题&lt;/li>
&lt;li>也可能是&lt;code>http://&lt;/code>和&lt;code>https://&lt;/code>之间的CORS问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这些都说明你在某个步骤上参数设置有问题，请对照步骤重新检查。&lt;/p>
&lt;h3 id="cicd-自定义域名设置">CI/CD 自定义域名设置&lt;/h3>
&lt;p>按照上述方式配置后，网站便能够以&lt;code>libre.fun&lt;/code>或&lt;code>www.libre.fun&lt;/code>来访问。但是如果你在本地修改了网站源码或内容，再次Push后，会发现地址失效了。这是因为Github Pages Setting是通过在&lt;code>gh-pages&lt;/code>根目录下放置CNAME文件来实现自定义域名的。而每次Push，会导致重新生成&lt;code>gh-pages&lt;/code>的文件，原本的CNAME也就不复存在。&lt;/p>
&lt;p>因此我们还需要在&lt;code>.github/workflows/gh-pages.yml&lt;/code>中做一些小修改。在文件最后加上一个&lt;code>cname&lt;/code>项即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#75715e"># ...&lt;/span>
- &lt;span style="color:#66d9ef">name&lt;/span>: Deploy
&lt;span style="color:#66d9ef">uses&lt;/span>: peaceiris/actions-gh-pages@v3
&lt;span style="color:#66d9ef">with&lt;/span>:
&lt;span style="color:#66d9ef">github_token&lt;/span>: ${{ secrets.GITHUB_TOKEN }}
&lt;span style="color:#66d9ef">publish_dir&lt;/span>: ./public
&lt;span style="color:#66d9ef">cname&lt;/span>: www.libre.fun
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote class="my-alert my-alert-note">
&lt;p>仍然是带&lt;code>www&lt;/code>前缀的域名。&lt;/p>
&lt;/blockquote>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>至此，一个基于Hugo，托管在Github Pages，且带有自动化CI/CD的静态个人网站就完成了。而且，经过一系列配置，网站使用HTTPS协议，可通过自定义域名访问（带不带&lt;code>www&lt;/code>前缀都可以）。&lt;/p>
&lt;p>之后的工作就是不断地完善自己的网站，添加更多的博客文章，并且在原主题更新的基础上，自己对主题进行定制，根据自己的需要，开启或关闭、添加或删除网站的某些功能。&lt;/p>
&lt;p>希望这篇文章能给打算自己建站的人带来帮助。&lt;/p>
- https://www.libre.fun/posts/build-site-with-hugo-and-github-pages/ - Libre. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>WSL 设置开机启动项</title><link>https://www.libre.fun/posts/setup-startup-in-wsl/</link><pubDate>Tue, 29 Oct 2019 14:30:09 +0800</pubDate><guid>https://www.libre.fun/posts/setup-startup-in-wsl/</guid><description>Libre's Blog https://www.libre.fun/posts/setup-startup-in-wsl/ -&lt;p>在 &lt;a href="https://www.libre.fun/posts/install-wsl-and-troubleshooting/">WSL Ubuntu的安装和Troubleshooting&lt;/a> 中，提到了WSL是一个阉割了部分功能的Linux，其中尤其是&lt;code>systemd&lt;/code>的阉割，使得不能方便地通过&lt;code>systemctl enable &amp;lt;service_name&amp;gt;&lt;/code>来把一个服务加入开机启动项内。&lt;/p>
&lt;p>但是对于大部分使用WSL的人而言，无论是出于刚性需求（例如在WSL中运行一个Web服务器）、还是使用方便（随时通过SSH连接到WSL），都可能需要在WSL中加入开机启动项。具体方法如下所述。&lt;/p>
&lt;p>本文阐述如何让一个WSL中的服务能够随Windows开机启动。以&lt;code>ssh&lt;/code>服务为例，该服务在WSL Ubuntu 18.04 LTS发行版中自带，但安装好后不会开机启动。&lt;/p>
&lt;h2 id="在wsl中写好启动项脚本">在WSL中写好启动项脚本&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">echo -e &lt;span style="color:#e6db74">&amp;#34;#! /bin/bash\n/etc/init.d/ssh start&amp;#34;&lt;/span> | tee -a /etc/init.wsl
chmod +x /etc/init.wsl
echo &lt;span style="color:#e6db74">&amp;#34;%sudo ALL=(ALL) NOPASSWD: /etc/init.wsl&amp;#34;&lt;/span> | tee -a /etc/sudoers
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的命令做了三件事：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在&lt;code>/etc&lt;/code>目录下生成名为&lt;code>init.wsl&lt;/code>的文件，并向其中写入以下两行内容：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e">#! /bin/bash
&lt;/span>&lt;span style="color:#75715e">&lt;/span>/etc/init.d/ssh start
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行向系统声明该脚本需要&lt;code>/bin/bash&lt;/code>来执行，第二行则是执行&lt;code>ssh&lt;/code>的启动脚本。&lt;/p>
&lt;p>如果你有其他服务需要开机启动，使用&lt;code>vim&lt;/code>编辑&lt;code>/etc/init.wsl&lt;/code>，并将下面命令中的&lt;code>&amp;lt;service_name&amp;gt;&lt;/code>替换成需要的服务名即可，该服务需要在&lt;code>/etc/init.d&lt;/code>目录下存在：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">/etc/init.d/&amp;lt;service_name&amp;gt; start
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>赋予&lt;code>/etc/init.wsl&lt;/code>脚本可执行权限&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在&lt;code>/etc/sudoers&lt;/code>文件中声明：执行&lt;code>/etc/init.wsl&lt;/code>脚本不需要输入密码&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="在windows中添加开机启动脚本">在Windows中添加开机启动脚本&lt;/h2>
&lt;p>由于WSL说到底还是Windows内置的一个“服务”，或者说是“组件”，因此对它的一些操作还是免不了要从Windows本身进行。&lt;/p>
&lt;p>按下「Win + R」，输入&lt;code>shell:startup&lt;/code>后回车，打开启动项文件夹。新建一个名为&lt;code>WhateverYouLike.vbs&lt;/code>的文件，并使用记事本或者VSCode打开它，输入以下内容：&lt;/p>
&lt;pre>&lt;code class="language-vbscript" data-lang="vbscript">Set ws = CreateObject(&amp;quot;Wscript.Shell&amp;quot;)
ws.run &amp;quot;bash -c &amp;quot;&amp;quot;sudo /etc/init.wsl&amp;quot;&amp;quot;&amp;quot;, vbhide
&lt;/code>&lt;/pre>&lt;p>我对VB脚本语言不太了解，但是大概能理解这两句的含义。&lt;/p>
&lt;p>第一句创建了一个可以执行命令的对象，命名为&lt;code>ws&lt;/code>；第二句调用了该对象的&lt;code>run&lt;/code>方法，执行了一句windows内的命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">bash -c &lt;span style="color:#e6db74">&amp;#34;sudo /etc/init.wsl&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>末尾传递的参数&lt;code>vbhide&lt;/code>是表示在后台执行该脚本。&lt;/p>
&lt;p>最后提一句，可以看到&lt;code>ws.run &amp;quot;bash -c &amp;quot;&amp;quot;sudo /etc/init.wsl&amp;quot;&amp;quot;&amp;quot;, vbhide&lt;/code>中有很多个双引号，看得人眼花缭乱，但这实际上是由于VBScript的转义字符规则所导致，实在谈不上美观。&lt;/p>
- https://www.libre.fun/posts/setup-startup-in-wsl/ - Libre. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>WSL 的安装和一些 Troubleshooting</title><link>https://www.libre.fun/posts/install-wsl-and-troubleshooting/</link><pubDate>Tue, 29 Oct 2019 12:50:09 +0800</pubDate><guid>https://www.libre.fun/posts/install-wsl-and-troubleshooting/</guid><description>Libre's Blog https://www.libre.fun/posts/install-wsl-and-troubleshooting/ -&lt;h2 id="什么是wsl">什么是WSL&lt;/h2>
&lt;p>WSL中文全称为「适用于 Linux 的 Windows 子系统」（Windows Subsystem for Linux），是一个为在Windows 10和Windows Server 2019上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。&lt;/p>
&lt;p>WSL相比于VMware等虚拟机解决方案更加轻量，启动速度更快，但代价是阉割了一些Linux系统的功能，例如&lt;code>systemd&lt;/code>、Ubuntu中的&lt;code>snapd&lt;/code>等（截止本文写作时）。但是对于一般Linux用户的使用是足够的。&lt;/p>
&lt;h2 id="wsl的启用">WSL的启用&lt;/h2>
&lt;p>在默认设置下，WSL是被关闭的，因此，首先需要在系统中开启WSL，有以下两种方式：&lt;/p>
&lt;h3 id="通过图形界面启用wsl">通过图形界面启用WSL&lt;/h3>
&lt;p>Windows「设置」➡「应用」➡右侧「程序和功能」➡「启用或关闭Windows功能」➡勾选「适用于 Linux 的 Windows 子系统」&lt;/p>
&lt;p>确定之后重启系统。&lt;/p>
&lt;h3 id="通过命令行启用wsl">通过命令行启用WSL&lt;/h3>
&lt;p>开始菜单按钮单击右键➡「Windows Powershell （管理员）」，打开Powershell后运行以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
&lt;/code>&lt;/pre>&lt;/div>&lt;p>开始下载相关数据，下载完成后输入「yes」重启系统。&lt;/p>
&lt;h2 id="wsl的安装">WSL的安装&lt;/h2>
&lt;p>在Windows中启用WSL之后，就可以安装你想使用的Linux发行版了，然而，这也要官方提供了相应的安装包才行。&lt;/p>
&lt;p>安装WSL同样有两种方式，一种是通过Microsoft Store安装，另一种是下载相应的应用包之后手动安装。鉴于Microsoft Store在网络方面的表现非常不稳定，推荐手动安装。&lt;/p>
&lt;h3 id="手动安装">手动安装👍&lt;/h3>
&lt;p>因为一些其他的原因，我之前就卸载了Microsoft Store，所以这里选择手动安装。根据&lt;a href="https://docs.microsoft.com/en-us/windows/wsl/install-manual">官方文档&lt;/a>，首先下载Ubuntu 18.04的Appx包，方便起见，将其重命名为&lt;code>ubuntu18.04.Appx&lt;/code>：&lt;/p>
&lt;figure>
&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20191029132023.png"/>
&lt;/figure>
&lt;p>假设下载好的包位于&lt;code>D:\Download&lt;/code>文件夹下，打开Powershell，运行以下命令即可安装：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">cd D:\Download
Add-AppxPackage .\ubuntu18.04.Appx
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="通过microsoft-store安装">通过Microsoft Store安装👎&lt;/h3>
&lt;p>进入Microsoft Store，搜索「Linux」，会出现官方提供的安装包，如下图所示（电脑上卸载了Microsoft Store，所以用网页版的截图代替一下）：&lt;/p>
&lt;figure>
&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20191029131346.png"/>
&lt;/figure>
&lt;p>选择你想要的版本进行安装，我这里选择了Ubuntu 18.04 LTS。&lt;/p>
&lt;h2 id="wsl的运行">WSL的运行&lt;/h2>
&lt;p>安装好之后就可以进入系统了，同样地，可以通过在CMD或则Powershell输入&lt;code>ubuntu1804.exe&lt;/code>直接在当前窗口进入WSL Ubuntu，也可以在开始菜单中找到新添加的&lt;code>Ubuntu 18.04&lt;/code>打开。&lt;/p>
&lt;p>安装之后初次运行需要一些初始化的时间，需要等待一下。WSL默认有一个&lt;code>root&lt;/code>用户，但初次运行通常会要求你添加一个新用户，按照提示输入用户名和密码即可，该用户会被自动成为&lt;code>sudoer&lt;/code>。如遇到提示「Permission Denied」或需要以&lt;code>root&lt;/code>身份运行某些命令时，在命令前加上&lt;code>sudo&lt;/code>即可。&lt;/p>
&lt;h2 id="troubleshooting">Troubleshooting&lt;/h2>
&lt;h3 id="wsl如何重启">WSL如何重启&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://superuser.com/questions/1126721/rebooting-ubuntu-on-windows-without-rebooting-windows">Rebooting Ubuntu on Windows without rebooting Windows?&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>如果你在WSL中执行了类似&lt;code>apt upgrade&lt;/code>的命令，可能会提示你需要重启WSL系统。然而，如果你想像正常的Linux那样执行&lt;code>reboot&lt;/code>命令，会提示无法执行。下面的Powershell（管理员）命令可以在不重启Windows系统的情况下重启WSL：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">Restart-Service LxssManager
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者CMD（管理员）命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">net stop LxssManager
net start LxssManager
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你的Windows版本大于等于Build 18917，还有更方便的：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">wsl --shutdown
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果系统中存在多个WSL发行版，你只想重启其中一个的话（需要Windows 1903+）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">wsl -t &amp;lt;DistroName&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="在windows中通过xshell等ssh工具无法连接到wsl">在Windows中通过XShell等SSH工具无法连接到WSL&lt;/h3>
&lt;p>要使用XShell（其他SSH工具均可，主要讨论的是WSL端的配置）SSH正确连接到WSL，以下几个方面都需要确认，遇到同样问题的朋友可以逐步排查：&lt;/p>
&lt;h4 id="确认wsl已经启动">确认WSL已经启动&lt;/h4>
&lt;p>在Windows中启动过一次WSL之后，在下次重启Windows系统之前，WSL都会一直在后台运行。但是一旦重启了Windows系统，就必须先启动WSL。&lt;/p>
&lt;p>如果想要WSL随Windows一起启动，可以将其写进计划任务里，通过以下命令即可让WSL开机启动：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">powershell.exe -WindowStyle Hidden -c &amp;lt;wsl-name&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>&amp;lt;wsl-name&amp;gt;&lt;/code>需要替换成你安装的WSL发行版启动程序名称，在本文中为&lt;code>ubuntu1804.exe&lt;/code>。&lt;/p>
&lt;h4 id="确认wsl中的ssh后台进程已经启动">确认WSL中的&lt;code>ssh&lt;/code>后台进程已经启动&lt;/h4>
&lt;p>可通过以下命令查看和启动：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">service ssh status
service ssh start
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认设置下，WSL中的&lt;code>ssh&lt;/code>服务不会开机启动。如果你是习惯使用XShell等工具连接到Linux主机，或是想要使用VSCode远程插件来使用WSL进行开发，那么你可能希望随时能够通过SSH连接到WSL，无须额外的手动操作。&lt;/p>
&lt;p>我把在WSL中设置开机启动项的方法写在了&lt;a href="https://www.libre.fun/posts/setup-startup-in-wsl/">这篇文章&lt;/a>中。&lt;/p>
&lt;h4 id="确认ssh-host-key正确存在">确认SSH Host Key正确存在&lt;/h4>
&lt;p>通过&lt;code>service ssh start&lt;/code>启动&lt;code>sshd&lt;/code>服务时，可能会出现如下提示：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ sudo service ssh start
* Starting OpenBSD Secure Shell server sshd Could not load host key: /etc/ssh/ssh_host_rsa_key
Could not load host key: /etc/ssh/ssh_host_ecdsa_key
Could not load host key: /etc/ssh/ssh_host_ed25519_key &lt;span style="color:#f92672">[&lt;/span> OK &lt;span style="color:#f92672">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为&lt;code>ssh&lt;/code>没有生成对应的主机密钥，一般来讲在安装&lt;code>ssh&lt;/code>时会自动生成，但是大概是WSL把这一部分阉割到了，我们可以通过以下命令来手动生成：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key
ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key
ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key
&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后通过&lt;code>service ssh --full-restart&lt;/code>重启服务。&lt;/p>
&lt;h4 id="sshd_config配置正确">&lt;code>sshd_config&lt;/code>配置正确&lt;/h4>
&lt;p>WSL自带的&lt;code>sshd&lt;/code>的配置中有很多导致不能登录成功的地方，通过以下命令打开&lt;code>sshd_config&lt;/code>进行查看和修改：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">vim /etc/ssh/sshd_config
&lt;/code>&lt;/pre>&lt;/div>&lt;p>确认以下几个选项没有没注释且你的&lt;code>sshd_config&lt;/code>中对应选项的值和这里是一样的：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">PasswordAuthentication yes
PermitEmptyPasswords yes
&lt;/code>&lt;/pre>&lt;/div>&lt;p>保存退出，&lt;code>service ssh restart&lt;/code>重启服务。&lt;/p>
&lt;h4 id="wsl中的ssh端口问题">WSL中的SSH端口问题&lt;/h4>
&lt;p>在摸索的过程中，我发现在StackOverflow论坛上，有人遇到了一个非常有意思的问题：当WSL的SSH端口为22时，无法连接，修改为其他端口号才可以，例如10022。修改方法也很简单，在&lt;code>sshd_config&lt;/code>中，查看和修改以下选项的值，确认未被注释：&lt;/p>
&lt;pre>&lt;code class="language-shel" data-lang="shel">Port 10022
&lt;/code>&lt;/pre>&lt;p>该问题我自己没有遇到，但是对于某些安装了SSH服务的Windows主机来说可能会出现，因为Windows首先要确保主系统的SSH（默认也是开放在22端口）正常工作，因此可能会对WSL中运行在22端口的SSH产生干扰。&lt;/p>
&lt;p>这里记录下来，以备后用。&lt;/p>
- https://www.libre.fun/posts/install-wsl-and-troubleshooting/ - Libre. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Docker 入门：镜像</title><link>https://www.libre.fun/posts/introduction-to-docker-image/</link><pubDate>Mon, 28 Oct 2019 10:58:00 +0800</pubDate><guid>https://www.libre.fun/posts/introduction-to-docker-image/</guid><description>Libre's Blog https://www.libre.fun/posts/introduction-to-docker-image/ -&lt;blockquote>
&lt;p>参考：&lt;a href="https://yeasy.gitbooks.io/docker_practice/image/">Docker — 从入门到实践&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="镜像的基本原理">镜像的基本原理&lt;/h2>
&lt;p>OS分为内核和用户空间。对于Linux而言，内核启动后， 会挂载 &lt;code>root&lt;/code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 &lt;code>root&lt;/code> 文件系统。比如官方镜像 &lt;code>ubuntu:18.04&lt;/code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 &lt;code>root&lt;/code> 文件系统。&lt;/p>
&lt;p>Docker中的镜像利用Union FS技术，被设计为分层存储的架构，由多层文件系统联合组成。&lt;/p>
&lt;p>镜像在构建时，会一层层构建，前一层是后一层的基础。 每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。&lt;/p>
&lt;p>分层存储的特征使得镜像的复用、定制变的更为容易。可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。&lt;/p>
&lt;h2 id="镜像仓库的相关概念">镜像仓库的相关概念&lt;/h2>
&lt;p>这里解释一下Docker镜像仓库相关的概念：&lt;/p>
&lt;p>首先，读者应该知道Linux系统中有软件源的概念，一个软件源提供了若干软件的下载、安装与更新。例如，Ubuntu系统中通过&lt;code>apt install&lt;/code>或者&lt;code>apt-get install&lt;/code>命令从预先配置的软件源中下载和安装软件，CentOS也有类似的&lt;code>yum install&lt;/code>等。&lt;/p>
&lt;p>在Docker的世界中，这样的「软件源」被称为&lt;strong>registry&lt;/strong>。registry用以保存Docker镜像，其中还包括镜像层次结构和关于镜像的元数据等。由Docker官方维护的registry被称为Docker Hub，用户也可以在自己的服务器上搭建私有的registry。&lt;/p>
&lt;p>Docker Hub并不是只有Docker官方才可以提供镜像，它类似Github，任何用户都可以创建账号，向Docker Hub上传自己制作的镜像。&lt;/p>
&lt;p>对于Docker Hub中存储的镜像，可以通过&lt;code>[username/]repository:tag&lt;/code>来唯一指定。&lt;/p>
&lt;ul>
&lt;li>如果不提供&lt;code>username&lt;/code>，则会指向Docker官方维护的镜像库，即&lt;code>library&lt;/code>；如果提供了&lt;code>username&lt;/code>，则指向的是该用户的镜像库（相当于账户）&lt;/li>
&lt;li>&lt;code>repository&lt;/code>表示的是具有某个功能的Docker镜像的所有迭代版本构成的镜像组，例如&lt;code>ubuntu&lt;/code>，其含义是包括Ubuntu 18.04、Ubuntu 16.04、Ubuntu 14.04等一系列镜像在内的镜像组&lt;/li>
&lt;li>&lt;code>tag&lt;/code>用于指出&lt;code>repository&lt;/code>中具体的某个镜像，例如&lt;code>ubuntu:latest&lt;/code>，意为指定该镜像库中最新版的Ubuntu镜像；再例如&lt;code>ubuntu:16.04&lt;/code>，意为指定版本号为16.04的Ubuntu镜像。&lt;/li>
&lt;/ul>
&lt;blockquote class="my-alert my-alert-note">
&lt;p>但是对于一条&lt;code>docker pull ubuntu&lt;/code>命令来说，并不是拉取了整个镜像组，而是会使用一个默认的&lt;code>tag&lt;/code>，即&lt;code>latest&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;blockquote class="my-alert my-alert-warning">
&lt;p>&lt;p>不要混淆镜像库和镜像组的概念：&lt;/p>
&lt;p>镜像库：默认为&lt;code>library&lt;/code>或由&lt;code>username&lt;/code>指定，是Docker官方或某用户提供的若干（不一定相关的）镜像组的集合；&lt;/p>
&lt;p>镜像组：由&lt;code>repository&lt;/code>，一般某个特定功能的镜像的若干迭代版本组成，每个迭代版本通常可以由一个标签指定，如上面举的&lt;code>ubuntu&lt;/code>的例子；&lt;/p>
&lt;p>因为&lt;code>library&lt;/code>和&lt;code>repository&lt;/code>在中文里都可以翻译为“库”，个人在看一些教程或书的时候也稍微混了一下，所以这里特意说明。&lt;/p>
&lt;/p>
&lt;/blockquote>
&lt;h2 id="获取镜像">获取镜像&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">docker pull &lt;span style="color:#f92672">[&lt;/span>options&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>docker_registry_address&lt;span style="color:#f92672">[&lt;/span>:port&lt;span style="color:#f92672">]&lt;/span>/&lt;span style="color:#f92672">]&lt;/span>repository&lt;span style="color:#f92672">[&lt;/span>:tag&lt;span style="color:#f92672">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>docker_registry_address：Docker镜像仓库地址，格式一般为&lt;code>domain/IP[:port]&lt;/code>。如果不给出，默认为Docker Hub&lt;/li>
&lt;li>repository：镜像名称，如&lt;code>ubuntu&lt;/code>&lt;/li>
&lt;li>tag：指出镜像的版本，例如&lt;code>ubuntu:18.04&lt;/code>，或者&lt;code>ubuntu:latest&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ docker pull ubuntu:18.04
latest: Pulling from library/ubuntu
22e816666fd6: Pull complete
079b6d2a1e53: Pull complete
11048ebae908: Pull complete
c58094023a2e: Pull complete
Digest: sha256:a7b8b7b33e44b123d7f997bd4d3d0a59fafc63e203d17efedf09ff3f6f516152
Status: Downloaded newer image &lt;span style="color:#66d9ef">for&lt;/span> ubuntu:latest
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的输出体现了分层存储的概念，镜像由多层存储构成，因此下载的时候也是一层一层地下载，这样也方便了本地镜像的复用，减少存储消耗。下载过程中给出了每一层的ID的前12位，该ID随着镜像的更新可能会有所变化；下载结束后，会给出该镜像完整的SHA256摘要，用以确认下载的一致性。&lt;/p>
&lt;h2 id="镜像运行">镜像运行&lt;/h2>
&lt;p>下面的命令给出了运行镜像的一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ docker run -it --rm ubuntu:18.04 bash
root@7ca7d3899f54:/# cat /etc/os-release
NAME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Ubuntu&amp;#34;&lt;/span>
VERSION&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;18.04.3 LTS (Bionic Beaver)&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># 略去一些输出&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>docker run&lt;/code>命令用于运行容器，这里涉及到的参数有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>-it&lt;/code>：&lt;code>-i&lt;/code>和&lt;code>-t&lt;/code>参数的合并形式，前者表示进行交互式操作，后者表示启动一个伪终端。
如果加&lt;code>-t&lt;/code>不加&lt;code>-i&lt;/code>，则会显示&lt;strong>伪终端&lt;/strong>，即命令行提示符，但无法输入命令与容器交互；如果加&lt;code>-t&lt;/code>不加&lt;code>-i&lt;/code>，则可以输入命令并执行，但不会显示伪终端，即没有命令行提示符。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>--rm&lt;/code>：表示在容器退出后删除，这里因为仅是试运行，因此指定退出后删除，避免浪费空间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ubuntu:18.04&lt;/code>：指出要加载的镜像&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>bash&lt;/code>：启动容器后执行的命令，因为我们想要一个交互式Shell，因此使用&lt;code>bash&lt;/code>·&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>进入容器后默认是以&lt;code>root&lt;/code>身份，此时可以像在常规Ubuntu系统中那样执行Shell命令，这里我们查看了一下系统信息。&lt;/p>
&lt;p>最后可以通过按下&lt;code>Ctrl+D&lt;/code>（退出当前会话）或输入&lt;code>exit&lt;/code>退出容器。&lt;/p>
&lt;blockquote class="my-alert my-alert-note">
&lt;p>事实上，此时按下 &lt;code>Ctrl+D&lt;/code> 或输入&lt;code>exit&lt;/code>是退出了&lt;code>bash&lt;/code>，并不等同于直接退出容器。真正导致容器退出的原因是该容器的主进程，即&lt;code>bash&lt;/code>退出了，主进程退出了，容器再无存在的必要，因此也随之退出了。&lt;/p>
&lt;/blockquote>
&lt;h2 id="查看本地镜像">查看本地镜像&lt;/h2>
&lt;p>&lt;code>docker image ls&lt;/code>命令用于列出已下载的镜像，并且提供了很多参数来定制输出。&lt;/p>
&lt;h3 id="无参数">无参数&lt;/h3>
&lt;p>不带参数的&lt;code>docker image ls&lt;/code>命令会列出本地所有&lt;strong>顶层&lt;/strong>镜像的信息，包括仓库名、标签、镜像ID、创建时间和占用的空间。&lt;/p>
&lt;blockquote>
&lt;p>与顶层镜像概念相对应的是中间层镜像，下文会提及&lt;/p>
&lt;/blockquote>
&lt;p>镜像ID是一个镜像唯一的标识，同一个镜像有可能对应多个标签。例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ docker image ls
REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu 18.04 cf0f3ca922e0 &lt;span style="color:#ae81ff">9&lt;/span> days ago 64.2MB
ubuntu latest cf0f3ca922e0 &lt;span style="color:#ae81ff">9&lt;/span> days ago 64.2MB
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为本文写作时，Docker官方镜像仓库中Ubuntu的最新版（latest）正是18.04，因此二者虽然标签不同，但是ID相同，对应的是同一个镜像。&lt;/p>
&lt;h3 id="-a列出所有镜像">&lt;code>-a&lt;/code>：列出所有镜像&lt;/h3>
&lt;p>相比于不带参数，带上&lt;code>-a&lt;/code>参数会列出所有的&lt;strong>中间层镜像&lt;/strong>，这些中间层镜像通常没有标签，是其他顶层镜像的依赖项，因此不要轻易删除。&lt;/p>
&lt;h3 id="列出部分镜像">列出部分镜像&lt;/h3>
&lt;ul>
&lt;li>&lt;code>docker image ls ubuntu&lt;/code>：根据镜像组名列出镜像&lt;/li>
&lt;li>&lt;code>docker image ls ubuntu:18.04&lt;/code>：列出某个特定的镜像&lt;/li>
&lt;li>&lt;code>-f&lt;/code>/&lt;code>--filter&lt;/code>：&lt;code>docker image ls&lt;/code>支持过滤器，加上&lt;code>-f&lt;/code>或者&lt;code>--filter&lt;/code>，随后提供条件即可，例如：
&lt;ul>
&lt;li>&lt;code>docker image ls -f since=ubuntu:latest&lt;/code>可以显示本地在&lt;code>ubuntu:latest&lt;/code>之后拉取或者构建的镜像&lt;/li>
&lt;li>同理，将&lt;code>since&lt;/code>替换成&lt;code>before&lt;/code>可以查看在某镜像之前拉取、构建的镜像&lt;/li>
&lt;li>如果构建镜像时定义了&lt;code>LABEL&lt;/code>，还可以使用类似&lt;code>docker image ls -f label=xxx&lt;/code>来过滤&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="定制输出格式">定制输出格式&lt;/h3>
&lt;p>&lt;code>docker image ls&lt;/code>可以利用Go的模板语法来定制输出格式，例如：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ docker image ls --format &lt;span style="color:#e6db74">&amp;#34;{{.ID}}: {{.Repository}}&amp;#34;&lt;/span>
540a289bab6c: nginx
cf0f3ca922e0: ubuntu
cf0f3ca922e0: ubuntu
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就可以只输出镜像的ID和镜像组名。值得一提的是，有时候为了批量删除镜像，通常会先用某种规则过滤出一批镜像ID，然后将输出作为参数传递给&lt;code>docker image rm&lt;/code>来删除指定镜像，这种情况下可以使用&lt;code>--format &amp;quot;{{.ID}}&amp;quot;&lt;/code>，也可以简单地使用&lt;code>-q&lt;/code>参数：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ docker image ls -q
540a289bab6c
cf0f3ca922e0
cf0f3ca922e0
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看镜像体积">查看镜像体积&lt;/h3>
&lt;p>在上面的&lt;code>docker image ls&lt;/code>无参数的示例中，我们可以看到本地每个镜像的体积（Size）。但实际上，这里有两点需要注意：&lt;/p>
&lt;ol>
&lt;li>该命令列出的每个镜像的体积与Docker Hub内对应镜像所显示的体积会有不同，通常比Docker Hub的更大。这是因为Docker Hub中显示的是压缩过的体积，方便网络传输，而本地的Size则是该镜像的完整体积。&lt;/li>
&lt;li>本地所有镜像的Size之和并不等于这些镜像实际占用的存储空间，因为不同镜像之间可能会复用一些中间层的镜像。&lt;/li>
&lt;/ol>
&lt;p>要查看镜像实际占用的空间，可以使用&lt;code>docker system df&lt;/code>命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ docker system df
TYPE TOTAL ACTIVE SIZE RECLAIMABLE
Images &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 190.4MB 190.4MB &lt;span style="color:#f92672">(&lt;/span>100%&lt;span style="color:#f92672">)&lt;/span>
Containers &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 0B 0B
Local Volumes &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 0B 0B
Build Cache &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> 0B 0B
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="虚悬镜像dangling-image">虚悬镜像(dangling image)&lt;/h3>
&lt;p>在使用Docker一段时间后，使用&lt;code>docker image ls&lt;/code>查看镜像列表时，可能会出现&lt;code>REPOSITORY&lt;/code>和&lt;code>TAG&lt;/code>均为&lt;code>&amp;lt;none&amp;gt;&lt;/code>的镜像，但是仍具有ID。&lt;/p>
&lt;p>这类镜像出现的原因是，随着镜像组的维护，新版本的镜像被发布，旧镜像的镜像名被转移到了新镜像的身上。例如&lt;code>ubuntu:18.04&lt;/code>，可能官方给其打了一个补丁后重新构建了镜像，但仍旧使用&lt;code>ubuntu:18.04&lt;/code>这个镜像名。虽然镜像名保持了旧的名称，但由于内容发生了变化，新镜像的ID也发生了变化。此时，旧的镜像的镜像名被“剥夺”，成为了所谓的“虚悬镜像”。&lt;/p>
&lt;p>使用&lt;code>docker image ls -f dangling=true&lt;/code>可以专门查看此类镜像。&lt;/p>
- https://www.libre.fun/posts/introduction-to-docker-image/ - Libre. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Ubuntu 18.04.3 各类代理配置</title><link>https://www.libre.fun/posts/vmware-ubuntu-proxy-configure/</link><pubDate>Tue, 15 Oct 2019 16:54:57 +0800</pubDate><guid>https://www.libre.fun/posts/vmware-ubuntu-proxy-configure/</guid><description>Libre's Blog https://www.libre.fun/posts/vmware-ubuntu-proxy-configure/ -&lt;p>本文主要阐述在Ubuntu系统中为一些软件配置代理的方法，包括APT、Snap、Git、Bash命令行以及Ubuntu系统层面的HTTP代理。&lt;/p>
&lt;h2 id="准备工作">准备工作&lt;/h2>
&lt;h3 id="实验环境">实验环境&lt;/h3>
&lt;p>本文中，笔者在VMware虚拟机中安装了Ubuntu系统，网络连接使用NAT模式。就代理的配置方式而言，无论虚拟机还是物理机都是通用的，区别只在于代理IP有所不同。在物理机上配置代理，只需要知道代理软件的IP（记作&lt;code>PROXY_IP&lt;/code>）和端口（本文中默认使用1080）。&lt;/p>
&lt;h3 id="虚拟机使用nat模式连接网络">虚拟机使用NAT模式连接网络&lt;/h3>
&lt;p>如果你是在虚拟机中安装了Ubuntu系统，则需要确认其网络访问方式为NAT。打开VMware，右键点击左侧「库」面板中安装好的虚拟机，进入「网络适配器」查看网络连接模式，将其设置为「NAT模式」，如下图所示&lt;/p>
&lt;figure>
&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20191105215106.png"/>
&lt;/figure>
&lt;h3 id="代理工具的准备">代理工具的准备&lt;/h3>
&lt;p>由于众所周知的原因，必须借助某些代理软件才能够实现对外网的流畅访问。&lt;/p>
&lt;p>&lt;strong>在SS或者SSR中，需要打开“允许来自局域网的连接”(SSR-windows 4.9.2)或者“允许其他设备连入”&lt;/strong>(SS-windows 4.1.7)等类似的选项。该选项的名称可能会根据代理软件版本的不同而有细微的差别。&lt;/p>
&lt;h3 id="在宿主机上安装xshell-可选">在宿主机上安装XShell （可选）&lt;/h3>
&lt;p>XShell是一个用于SSH连接到主机的工具，这里推荐安装和使用。如果没有使用过这类工具的用户可以略过。&lt;/p>
&lt;h3 id="确认代理ip地址">确认代理IP地址&lt;/h3>
&lt;p>在虚拟机方案中，通常是宿主机上运行代理软件，然后配置虚拟机Ubuntu系统的代理，从而使Ubuntu正常访问外网。此时则需要查看宿主机的IP地址。&lt;/p>
&lt;p>以Windows为例，按下「Win+R」，输入&lt;code>cmd&lt;/code>并按下回车，打开Windows命令提示符。&lt;/p>
&lt;p>输入&lt;code>ipconfig&lt;/code>，在「以太网适配器 VMware Network Adapter VMnet8」中查看IPv4地址，通常以&lt;code>172.16/17/18&lt;/code>或者&lt;code>192.168&lt;/code>开头。&lt;/p>
&lt;blockquote>
&lt;p>VMware Network Adapter VMnet8 是VMware中使用NAT模式的虚拟机专用的网络适配器。&lt;/p>
&lt;/blockquote>
&lt;p>将该IP地址记为&lt;code>PROXY_IP&lt;/code>，即我们需要的代理IP地址。后文中将始终使用&lt;code>PROXY_IP&lt;/code>。读者在实践时需要替换为自己查看到的IP地址。&lt;/p>
&lt;h3 id="确认代理端口号">确认代理端口号&lt;/h3>
&lt;p>一般来讲，如果没有做过更改，SS和SSR使用的代理端口号都是&lt;code>1080&lt;/code>。所以本文的命令中都会使用&lt;code>1080&lt;/code>这个端口号。&lt;/p>
&lt;h3 id="确认系统权限">确认系统权限&lt;/h3>
&lt;p>本文中使用的部分命令需要&lt;code>root&lt;/code>权限，如果在&lt;code>root&lt;/code>账户下，则可以直接执行命令；如果是在普通账户下，需要在命令前加上&lt;code>sudo&lt;/code>关键字。&lt;/p>
&lt;h2 id="apt代理配置">APT代理配置&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://www.serverlab.ca/tutorials/linux/administration-linux/how-to-set-the-proxy-for-apt-for-ubuntu-18-04/">How to Set the Proxy for APT on Ubuntu 18.04&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>APT是Ubuntu系统内常用的软件包管理器，为APT配置代理之后能够保证一些软件可以正常安装，安装速度通常也会有一定的提升。&lt;/p>
&lt;p>给APT配置代理的步骤如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ sudo apt install vim
&lt;span style="color:#75715e"># 该命令是为了安装Vim编辑器，Ubuntu不自带Vim；如果已安装，则可以忽略这一条&lt;/span>
$ sudo vim /etc/apt/apt.conf.d/proxy.conf
&lt;span style="color:#75715e"># 此时会创建并打开一个名为proxy.conf的文件，按下I进入编辑模式，输入以下几行&lt;/span>
Acquire &lt;span style="color:#f92672">{&lt;/span>
HTTP::proxy &lt;span style="color:#e6db74">&amp;#34;http://PROXY_IP:1080&amp;#34;&lt;/span>;
HTTPS::proxy &lt;span style="color:#e6db74">&amp;#34;http://PROXY_IP:1080&amp;#34;&lt;/span>;
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e"># 输入后按下Esc，然后输入:wq，按下回车即可保存退出&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>打开代理软件（SS或者SSR）的流量监控，使用&lt;code>apt-get install&lt;/code>命令安装任意一个包，查看下载速度并和宿主机上的流量监控数据进行对照，如果速度接近，即说明代理配置成功。&lt;/p>
&lt;blockquote>
&lt;p>加快APT安装速度还有其他方案，例如替换为淘宝源等。&lt;/p>
&lt;/blockquote>
&lt;h2 id="snap代理配置">Snap代理配置&lt;/h2>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://blog.shunwww.cn/2019/02/19/yuque/proxy-snap/">使用代理安装 SNAP 包以加速下载&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Snap也是Ubuntu下使用比较多的一个软件包管理器，而且个人觉得它要比APT更好用，很多流行软件也都支持通过Snap安装，因此如果你在使用Snap时觉得下载速度太慢，那可能也需要为其配置代理。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ systemctl edit snapd
&lt;span style="color:#75715e"># 此时会打开一个编辑器，直接输入以下内容：&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
Environment&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http_proxy=PROXY_IP:1080&amp;#34;&lt;/span>
Environment&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;https_proxy=PROXY_IP:1080&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># 注意在输入上述内容时，小键盘的数字键是不可用的，如果不小心按了小键盘的数字键进入了奇怪的模式，按下Ctrl+C即可取消，然后接着输入即可&lt;/span>
&lt;span style="color:#75715e"># 输入完成后，按下Ctrl+O，然后回车保存，然后Ctrl+X退出&lt;/span>
&lt;span style="color:#75715e"># 然后重启Snap后台进程&lt;/span>
$ systemctl daemon-reload
$ systemctl restart snapd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样地，使用&lt;code>snap install&lt;/code>安装任意一个包， 对照代理软件的流量监控，查看是否配置成功。&lt;/p>
&lt;h2 id="git代理配置">Git代理配置&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">git config --global http.proxy http://PROXY_IP:1080
git config --global https.proxy http://PROXY_IP:1080
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ubuntu系统层面的http代理">Ubuntu系统层面的HTTP代理&lt;/h2>
&lt;p>使用Ubuntu时，肯定还会有访问一些网页的需求，例如Google，因此还需要给Ubuntu配置一下系统全局代理，这样才能让浏览器的HTTP和HTTPS请求走代理。&lt;/p>
&lt;p>这一步使用图形界面或者命令行都可以做，这里各自说一下。&lt;/p>
&lt;h3 id="图形界面">图形界面&lt;/h3>
&lt;p>打开「设置/Settings」➡「网络/Network」➡「代理/Network Proxy」，按照下图所示进行输入，记得将&lt;code>PROXY_IP&lt;/code>替换为宿主机的IP：&lt;/p>
&lt;figure>
&lt;img src="https://image-hosting-1251771285.cos.ap-guangzhou.myqcloud.com/20191002133051.png"/>
&lt;/figure>
&lt;p>其中&lt;code>Ignore Hosts&lt;/code>中填入以下内容，使局域网IP绕过代理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">localhost, 127.0.0.0/8, ::1, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16,
&lt;/code>&lt;/pre>&lt;/div>&lt;p>填好之后直接关闭即可，可打开Firefox或者Chrome浏览器访问Google进行测试。&lt;/p>
&lt;h3 id="命令行">命令行&lt;/h3>
&lt;blockquote>
&lt;p>参考：&lt;a href="https://kifarunix.com/how-to-set-system-wide-proxy-in-ubuntu-18-04/">How to Set System Wide Proxy in Ubuntu 18.04&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在命令行下，通常是通过设置环境变量来配置代理，执行以下命令即可：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">export http_proxy&lt;span style="color:#f92672">=&lt;/span>http://PROXY_IP:1080
export https_proxy&lt;span style="color:#f92672">=&lt;/span>http://PROXY_IP:1080
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是这种方式只会在当前会话中起作用，如果你是通过XShell连接的Ubuntu，或者打开了一个Bash终端，那么关闭会话/关闭终端后该环境变量就会失效。&lt;/p>
&lt;p>如果你想为系统永久配置代理，则需要进一步编辑配置文件。然而这里也有两种策略：&lt;/p>
&lt;ul>
&lt;li>只为当前用户配置代理&lt;/li>
&lt;li>为系统的所有用户配置代理（包括root）&lt;/li>
&lt;/ul>
&lt;h4 id="只为当前用户配置代理">只为当前用户配置代理&lt;/h4>
&lt;p>做法是修改当前用户的.bashrc，具体操作如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ cd
&lt;span style="color:#75715e"># 确保位于当前用户的home目录下&lt;/span>
&lt;span style="color:#75715e"># 将两行命令写入.bashrc文件内&lt;/span>
$ echo -e &lt;span style="color:#e6db74">&amp;#34;export http_proxy=http://PROXY_IP:1080/\nexport https_proxy=https://PROXY_IP:1080/&amp;#34;&lt;/span> | tee -a .bashrc
&lt;span style="color:#75715e"># 该命令不会立即生效，重启shell才能生效；要使它立即生效，可以执行以下命令：&lt;/span>
$ source .bashrc
&lt;span style="color:#75715e"># 输入以下命令测试是否成功：&lt;/span>
$ wget google.com
--2019-10-01 22:39:42-- http://google.com/
Connecting to 172.16.171.22:1080... connected.
Proxy request sent, awaiting response... &lt;span style="color:#ae81ff">301&lt;/span> Moved Permanently
Location: http://www.google.com/ &lt;span style="color:#f92672">[&lt;/span>following&lt;span style="color:#f92672">]&lt;/span>
--2019-10-01 22:39:43-- http://www.google.com/
Connecting to 172.16.171.22:1080... connected.
Proxy request sent, awaiting response... &lt;span style="color:#ae81ff">200&lt;/span> OK
Length: unspecified &lt;span style="color:#f92672">[&lt;/span>text/html&lt;span style="color:#f92672">]&lt;/span>
Saving to: ‘index.html’
index.html &lt;span style="color:#f92672">[&lt;/span> &amp;lt;&lt;span style="color:#f92672">=&lt;/span>&amp;gt; &lt;span style="color:#f92672">]&lt;/span> 11.47K --.-KB/s in 0s
2019-10-01 22:39:43 &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">233&lt;/span> MB/s&lt;span style="color:#f92672">)&lt;/span> - ‘index.html’ saved &lt;span style="color:#f92672">[&lt;/span>11746&lt;span style="color:#f92672">]&lt;/span>
&lt;span style="color:#75715e"># 出现类似以上的信息即说明配置成功&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="为系统所有用户配置代理">为系统所有用户配置代理&lt;/h4>
&lt;p>如果你尝试了刚刚说的方法，会发现在当前的普通用户下的网络访问是可以走代理的，但是如果切换到&lt;code>root&lt;/code>账号，再执行&lt;code>wget google.com&lt;/code>，就会发现连接不上，这是因为刚刚修改的&lt;code>.bashrc&lt;/code>文件是属于那个普通账户的，也只会对那个普通用户的bash命令行起作用，其他用户的网络访问则不走代理。&lt;/p>
&lt;p>想要一次性为系统的所有用户配置代理，需要修改&lt;code>/etc/environment&lt;/code>文件：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ echo -e &lt;span style="color:#e6db74">&amp;#34;http_proxy=http://PROXY_IP:1080/\nhttps_proxy=https://PROXY_IP:1080/&amp;#34;&lt;/span> | sudo tee -a /etc/environment
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种配置方法在重新登录后才会生效。&lt;/p>
- https://www.libre.fun/posts/vmware-ubuntu-proxy-configure/ - Libre. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>CentOS 7.6 Minimal Installation 后无法连接网络</title><link>https://www.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/</link><pubDate>Sat, 05 Oct 2019 12:53:00 +0800</pubDate><guid>https://www.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/</guid><description>Libre's Blog https://www.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/ -&lt;h2 id="问题原因">问题原因&lt;/h2>
&lt;p>在安装CentOS 7.6系统时，图形安装界面的部分有一个配置网络的选项，进去之后可以开启网卡，而Minimal Installation默认是不开启网卡的，因此如果在安装系统时由于疏忽忘记打开网卡，进入系统之后会发现无法联网，所有和网络有关的操作都会报错。&lt;/p>
&lt;h2 id="解决方法">解决方法&lt;/h2>
&lt;p>首先通过命令&lt;code>nmcli d&lt;/code>查看网卡启用状态：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>libre@localhost ~&lt;span style="color:#f92672">]&lt;/span>$ nmcli d
DEVICE TYPE STATE CONNECTION
ens33 ethernet disconnected --
lo loopback unmanaged --
&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现网卡的确是未启用。然后编辑文件&lt;code>/etc/sysconfig/network-scripts/ifcfg-ens&amp;lt;num&amp;gt;&lt;/code>，此处的&lt;code>&amp;lt;num&amp;gt;&lt;/code>在每台机器可能不一样，使用Tab自动补全即可。&lt;/p>
&lt;p>将该文件最后一行的&lt;code>ONBOOT=NO&lt;/code>改为&lt;code>ONBOOT=YES&lt;/code>，然后保存退出，再通过以下命令重启网络：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">service network restart
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时再查看网卡状态：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>libre@localhost ~&lt;span style="color:#f92672">]&lt;/span>$ nmcli d
DEVICE TYPE STATE CONNECTION
ens33 ethernet connected ens33
lo loopback unmanaged --
&lt;/code>&lt;/pre>&lt;/div>&lt;p>搞定。&lt;/p>
- https://www.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/ - Libre. 本站遵循 CC-BY-NC 4.0 协议</description></item></channel></rss>