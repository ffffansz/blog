<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Libre's Blog</title><link>https://www.libre.fun/posts/</link><description>Recent content in Posts on Libre's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>Libre. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Thu, 23 Apr 2020 15:24:28 +0800</lastBuildDate><atom:link href="https://www.libre.fun/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Github Pages搭建个人博客的最佳实践</title><link>https://www.libre.fun/posts/best-practices-for-building-blog-with-ghpage/</link><pubDate>Thu, 23 Apr 2020 15:24:28 +0800</pubDate><guid>https://www.libre.fun/posts/best-practices-for-building-blog-with-ghpage/</guid><description>引言 前不久使用Hugo重新搭建了自己的站点，利用Github Pages托管，也将整个过程记录了下来。其中，利用Github Actions实现CI/CD是我认为非常重要的一环，可以大大简化个人博客的更新流程。
随着近半个月的使用，我的博客也发生了一些变化。由于要添加评论系统，需要在config.toml中写入一些Secrets，因此我将博客背后的托管逻辑进行了一些修改。
在修改前，我只使用一个ffffansz/blog仓库，其中master分支包含了源码和仓库的README，而gh-pages分支则用于发布博客内容，该分支利用peaceiris/actions-gh-pages@v3进行更新，在每次master分支push时触发。
修改后，仓库变成了两个，一个私有仓库ffffansz/blog-src，一个公有仓库ffffansz/blog。从名称不难想到，blog-src存放博客源码，只有一个master分支；blog仓库仍然具有两个分支，master分支存放README和网站的CHANGELOG，gh-pages分支和之前一样，用于发布Github Pages内容。
个人认为，这种模式保证了私密信息的安全性，也在展示方面非常优雅。
如有他人访问你的Github Profile，进入blog仓库，默认展现master分支，只有简单的两个Markdown文件，README可用于放置博客链接和一些文字介绍，CHANGELOG则是你自己记录博客更迭过程的一个日记。另一方面，有一些不便公开的信息，例如某些评论系统的Key，或是Google Analytics的UA号，则被隐藏在自己的私有仓库中。
本文主要介绍我个人心中利用Github Pages搭建个人博客的最佳实践：Github仓库分布的设计，利用Github Actions实现CI/CD的流程等。也欢迎各位在评论区分享自己的个人博客搭建心得😊。
本文的讨论不局限于任何特定的静态网站生成器。
Github Pages发布内容的几种方式 为了进行示例，这里我创建一个名为exampleSite的仓库，并且创建了master和gh-pages两个分支。在Github上进入该仓库的「Setting」页面，有一名为「Github Pages」的模块。其中，点击「Source」下的下拉菜单，可以看到几种Github Pages发布内容的方式。
此处的「内容」，特指静态网站生成器，如Hugo/Hexo/Gitbook等，处理网站源码后生成的用于发布的诸多网页文件。以Hugo为例，运行hugo命令后，会生成public目录。该目录下的文件就是本文所称的「内容」。
这里由于仓库包含了gh-pages分支，因此系统默认启用Github Pages并选择了该方式。其他情况下，需要手动启用。
有三种方式：
发布gh-pages分支下所有内容👍 发布master分支下所有内容 发布master分支下/docs目录下所有内容 本文推荐使用第一种方式。理由在引言部分已有阐述：仓库首页干净简洁，纷乱的网站内容目录被隐藏到了gh-pages分支下。
看到这里有读者可能会想到，建立一个blog仓库，使用三个分支：master分支只放README——保证了干净，src分支放网站源码，gh-pages分支放网站内容。
但是这样一来，网站源码和网站内容，仍然处在同一个仓库内。然而我个人提倡将二者分离开来，这就是下一节要讨论的内容。
分离博客源码和内容 以本站为例子来说明为什么要进行分离。
起初，博客不具有评论功能。经过比较，我决定使用「Gitalk」为博客提供评论系统支持。根据网站使用的框架与主题，需要在网站源码目录的config.toml中，填入以下信息：
[params.gitalk] owner = &amp;#34;&amp;lt;your-github-username&amp;gt;&amp;#34; repo = &amp;#34;&amp;lt;your-repository-used-for-placing-comments&amp;gt;&amp;#34; client_id = &amp;#34;&amp;lt;some_id&amp;gt;&amp;#34; client_secret = &amp;#34;&amp;lt;some_secret&amp;gt;&amp;#34; 这里的client_secret和client_id我是不愿暴露在公有仓库中的。虽然对于Gitalk而言，即使这两个信息暴露，其他人也无法对你造成什么干扰。但是如果推广到更多情况，我认为总有一些信息是不应当暴露到公有仓库的。
为了实现源码和内容的分离，我们可以再创建一个私有仓库，取名为blog-src。然后将博客源码托管在该仓库内。
利用Github Actions实现CI/CD CI/CD，意为持续集成/持续部署，是软件工程中的名词。在个人博客搭建这件事上，CI/CD可以实现的效果是：本地新增或修改了一篇文章，推送到blog-src仓库后，可以在较短时间（10分钟以内），自动将博客的改动反映至博客主页上。
如果不借助Github Actions实现CI/CD，往往我们需要一些手动工作才能更新博客。以Hugo为例，修改过博客的样式或是文章后，我们需要在本地手动执行hugo命令生成public目录，然后将public目录下的内容手动推送至gh-pages分支，或是将public目录名修改为docs（Github Pages的设置则需要修改为方式3），等等，不够省心。
得益于社区的贡献，目前已有很多开箱即用的Github Actions，本文推荐使用peaceiris/actions-gh-pages。另外，本网站使用了Hugo作为静态网站生成器，因此还需要peaceiris/actions-hugo，以实现本地修改push到仓库后，在线进行博客内容的构建，而省去了本地构建的麻烦。
对于其他静态网站生成器，也可以在Github上找到对应的Actions；本质上，Github Actions的原理就是在Github的服务端运行容器，然后根据需要抽取出相应的内容。你也可以模仿peaceiris/actions-hugo来实现自己所需的Actions。
添加Github Actions的方式很简单，在博客源码目录下新建.github/workflows目录，然后在其中建立gh-pages.yml文件，然后按照一定的语法指定Actions，下面给出本站使用的Actions：
name: Github Pages Deploy # Actions的名称，说明用途 on: push: # 在仓库收到push时触发 branches: - master # 指定是master分支收到push时 jobs: deploy: runs-on: ubuntu-18.</description></item><item><title>Hugo &amp; Github Pages 建站过程全记录</title><link>https://www.libre.fun/posts/build-site-with-hugo-and-github-pages/</link><pubDate>Sun, 12 Apr 2020 02:55:32 +0800</pubDate><guid>https://www.libre.fun/posts/build-site-with-hugo-and-github-pages/</guid><description>整体步骤 之前也使用Hugo搭建过几次个人博客，但是由于各种各样的问题始终不甚满意，未能持续运行。这次再从头搭建一次，力求将各种细节都做到让自己满意。
博客搭建的整体步骤如下：
从hugo new site建立的空项目开始，逐步添加内容。项目根路径记为Site
在项目目录下建立Git仓库，然后Push到Github，Github上对应的仓库名为blog
主题使用Git的子模块（Submodule）功能进行管理
修改主题时，不去修改主题子模块本身的文件，而是将对应的样式文件、HTML或JS文件SCSS或HTML文件复制到Site目录下对应的目录再进行修改。由于Hugo的样式查找策略，会使用Site下的样式文件去替代themes/&amp;lt;theme-name&amp;gt;下的样式文件。
这么做主要是考虑到主题后续还会更新，其样式文件会发生变化。Submodule功能可以指定子模块的某次commit作为主项目使用的版本，更新与否取决于主项目是否想要使用新的版本。
网站使用Github Pages发布，操作方式是在blog仓库中创建gh-pages分支，之后在仓库Setting页设置Source即可
使用自定义域名
利用Github Actions实现CI/CD，只需在本地master分支修改网站源码、添加博客内容，之后将master分支推送至Github即可，网站的生成和部署都由Github Actions完成。
接下来是对建站过程的一个记录，途中碰到的问题也会一并记录下来。
Git使用规范 之前使用Git的时候，自己有一个不好的习惯是修改一堆东西之后Commit一次，这样一来不但Commit Message不好写，而且版本管理也是一团糟，不利于版本回顾。
所以这次强迫自己，所有修改以功能点为单位，修改完一个点就Commit一次。
举个例子，假设我现在需要做两件事：(1) 修改文章标签的样式，(2) 修改Footer处的Copy Right。那么每做一件事，就Commit一次，并写清楚对应的Commit Message。
多说一句，Git的功能非常强大，使用得当可以节省大量的时间。Git入门我推荐廖雪峰的Git教程，浅显易懂。我个人对Git的掌握也非常粗浅，只能通过不断地实践来熟悉它了。
工具准备 本次搭建的是一个静态网站，使用的工具包括静态网站生成器Hugo、Git、Github Pages，以及一个基本的代码编辑器，推荐VSCode。使用的操作系统为Windows 10。
在Hugo - Github下载最新的Release，注意extended版本才支持SCSS样式文件；平台是Windows，所以这里选择下载hugo_extended_0.68.3_Windows-64bit.zip；解压后得到hugo.exe文件，在D盘下建立文件夹Hugo，将hugo.exe放入（即D:\Hugo\hugo.exe）。然后在「环境变量」→「系统变量」→Path中添加D:\Hugo，即可在终端（CMD、Powershell、VSCode Terminal）中使用hugo命令。 在Git Downloads中下载Windows版本的Git安装包，本文写作时的版本是2.26.0，有一大堆安装选项，之后有空的话我再写一篇文章专门解释各个选项的意思。#TODO Github Pages是Github推出的一项免费托管服务，可以根据Github仓库内的文件将其转换为可直接访问的网站，域名是&amp;lt;github-username&amp;gt;.github.io，也可以自定义域名。只需拥有一个Github账号即可使用该功能。 下文的所有命令，均在VSCode Terminal内执行（实质就是在VSCode内调用了Windows内置的Powershell）。
项目初始化 首先在Github上建立一个新仓库，名为blog，用于托管本次网站项目的源码。
接着在某个本地目录下操作，这里我选择了D盘根路径：
cd D:\ git clone https://github.com/ffffansz/blog.git Site 这样我们的Site文件夹在本地的绝对路径就是D:\Site。</description></item><item><title>WSL 设置开机启动项</title><link>https://www.libre.fun/posts/setup-startup-in-wsl/</link><pubDate>Tue, 29 Oct 2019 14:30:09 +0800</pubDate><guid>https://www.libre.fun/posts/setup-startup-in-wsl/</guid><description>在 WSL Ubuntu的安装和Troubleshooting 中，提到了WSL是一个阉割了部分功能的Linux，其中尤其是systemd的阉割，使得不能方便地通过systemctl enable &amp;lt;service_name&amp;gt;来把一个服务加入开机启动项内。
但是对于大部分使用WSL的人而言，无论是出于刚性需求（例如在WSL中运行一个Web服务器）、还是使用方便（随时通过SSH连接到WSL），都可能需要在WSL中加入开机启动项。具体方法如下所述。
本文阐述如何让一个WSL中的服务能够随Windows开机启动。以ssh服务为例，该服务在WSL Ubuntu 18.04 LTS发行版中自带，但安装好后不会开机启动。
在WSL中写好启动项脚本 echo -e &amp;#34;#! /bin/bash\n/etc/init.d/ssh start&amp;#34; | tee -a /etc/init.wsl chmod +x /etc/init.wsl echo &amp;#34;%sudo ALL=(ALL) NOPASSWD: /etc/init.wsl&amp;#34; | tee -a /etc/sudoers 上面的命令做了三件事：
在/etc目录下生成名为init.wsl的文件，并向其中写入以下两行内容：
#! /bin/bash /etc/init.d/ssh start 第一行向系统声明该脚本需要/bin/bash来执行，第二行则是执行ssh的启动脚本。
如果你有其他服务需要开机启动，使用vim编辑/etc/init.wsl，并将下面命令中的&amp;lt;service_name&amp;gt;替换成需要的服务名即可，该服务需要在/etc/init.d目录下存在：
/etc/init.d/&amp;lt;service_name&amp;gt; start 赋予/etc/init.wsl脚本可执行权限
在/etc/sudoers文件中声明：执行/etc/init.wsl脚本不需要输入密码
在Windows中添加开机启动脚本 由于WSL说到底还是Windows内置的一个“服务”，或者说是“组件”，因此对它的一些操作还是免不了要从Windows本身进行。
按下「Win + R」，输入shell:startup后回车，打开启动项文件夹。新建一个名为WhateverYouLike.vbs的文件，并使用记事本或者VSCode打开它，输入以下内容：
Set ws = CreateObject(&amp;quot;Wscript.Shell&amp;quot;) ws.run &amp;quot;bash -c &amp;quot;&amp;quot;sudo /etc/init.wsl&amp;quot;&amp;quot;&amp;quot;, vbhide 我对VB脚本语言不太了解，但是大概能理解这两句的含义。
第一句创建了一个可以执行命令的对象，命名为ws；第二句调用了该对象的run方法，执行了一句windows内的命令：</description></item><item><title>WSL 的安装和一些 Troubleshooting</title><link>https://www.libre.fun/posts/install-wsl-and-troubleshooting/</link><pubDate>Tue, 29 Oct 2019 12:50:09 +0800</pubDate><guid>https://www.libre.fun/posts/install-wsl-and-troubleshooting/</guid><description>什么是WSL WSL中文全称为「适用于 Linux 的 Windows 子系统」（Windows Subsystem for Linux），是一个为在Windows 10和Windows Server 2019上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。
WSL相比于VMware等虚拟机解决方案更加轻量，启动速度更快，但代价是阉割了一些Linux系统的功能，例如systemd、Ubuntu中的snapd等（截止本文写作时）。但是对于一般Linux用户的使用是足够的。
WSL的启用 在默认设置下，WSL是被关闭的，因此，首先需要在系统中开启WSL，有以下两种方式：
通过图形界面启用WSL Windows「设置」➡「应用」➡右侧「程序和功能」➡「启用或关闭Windows功能」➡勾选「适用于 Linux 的 Windows 子系统」
确定之后重启系统。
通过命令行启用WSL 开始菜单按钮单击右键➡「Windows Powershell （管理员）」，打开Powershell后运行以下命令：
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 开始下载相关数据，下载完成后输入「yes」重启系统。
WSL的安装 在Windows中启用WSL之后，就可以安装你想使用的Linux发行版了，然而，这也要官方提供了相应的安装包才行。
安装WSL同样有两种方式，一种是通过Microsoft Store安装，另一种是下载相应的应用包之后手动安装。鉴于Microsoft Store在网络方面的表现非常不稳定，推荐手动安装。
手动安装👍 因为一些其他的原因，我之前就卸载了Microsoft Store，所以这里选择手动安装。根据官方文档，首先下载Ubuntu 18.04的Appx包，方便起见，将其重命名为ubuntu18.04.Appx：
假设下载好的包位于D:\Download文件夹下，打开Powershell，运行以下命令即可安装：
cd D:\Download Add-AppxPackage .\ubuntu18.04.Appx 通过Microsoft Store安装👎 进入Microsoft Store，搜索「Linux」，会出现官方提供的安装包，如下图所示（电脑上卸载了Microsoft Store，所以用网页版的截图代替一下）：
选择你想要的版本进行安装，我这里选择了Ubuntu 18.04 LTS。
WSL的运行 安装好之后就可以进入系统了，同样地，可以通过在CMD或则Powershell输入ubuntu1804.exe直接在当前窗口进入WSL Ubuntu，也可以在开始菜单中找到新添加的Ubuntu 18.04打开。
安装之后初次运行需要一些初始化的时间，需要等待一下。WSL默认有一个root用户，但初次运行通常会要求你添加一个新用户，按照提示输入用户名和密码即可，该用户会被自动成为sudoer。如遇到提示「Permission Denied」或需要以root身份运行某些命令时，在命令前加上sudo即可。
Troubleshooting WSL如何重启 参考：Rebooting Ubuntu on Windows without rebooting Windows?</description></item><item><title>Docker 入门：镜像</title><link>https://www.libre.fun/posts/introduction-to-docker-image/</link><pubDate>Mon, 28 Oct 2019 10:58:00 +0800</pubDate><guid>https://www.libre.fun/posts/introduction-to-docker-image/</guid><description>参考：Docker — 从入门到实践
镜像的基本原理 OS分为内核和用户空间。对于Linux而言，内核启动后， 会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。
Docker中的镜像利用Union FS技术，被设计为分层存储的架构，由多层文件系统联合组成。
镜像在构建时，会一层层构建，前一层是后一层的基础。 每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。
分层存储的特征使得镜像的复用、定制变的更为容易。可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
镜像仓库的相关概念 这里解释一下Docker镜像仓库相关的概念：
首先，读者应该知道Linux系统中有软件源的概念，一个软件源提供了若干软件的下载、安装与更新。例如，Ubuntu系统中通过apt install或者apt-get install命令从预先配置的软件源中下载和安装软件，CentOS也有类似的yum install等。
在Docker的世界中，这样的「软件源」被称为registry。registry用以保存Docker镜像，其中还包括镜像层次结构和关于镜像的元数据等。由Docker官方维护的registry被称为Docker Hub，用户也可以在自己的服务器上搭建私有的registry。
Docker Hub并不是只有Docker官方才可以提供镜像，它类似Github，任何用户都可以创建账号，向Docker Hub上传自己制作的镜像。
对于Docker Hub中存储的镜像，可以通过[username/]repository:tag来唯一指定。
如果不提供username，则会指向Docker官方维护的镜像库，即library；如果提供了username，则指向的是该用户的镜像库（相当于账户） repository表示的是具有某个功能的Docker镜像的所有迭代版本构成的镜像组，例如ubuntu，其含义是包括Ubuntu 18.04、Ubuntu 16.04、Ubuntu 14.04等一系列镜像在内的镜像组 tag用于指出repository中具体的某个镜像，例如ubuntu:latest，意为指定该镜像库中最新版的Ubuntu镜像；再例如ubuntu:16.04，意为指定版本号为16.04的Ubuntu镜像。 但是对于一条docker pull ubuntu命令来说，并不是拉取了整个镜像组，而是会使用一个默认的tag，即latest
不要混淆镜像库和镜像组的概念：
镜像库：默认为library或由username指定，是Docker官方或某用户提供的若干（不一定相关的）镜像组的集合；
镜像组：由repository，一般某个特定功能的镜像的若干迭代版本组成，每个迭代版本通常可以由一个标签指定，如上面举的ubuntu的例子；
因为library和repository在中文里都可以翻译为“库”，个人在看一些教程或书的时候也稍微混了一下，所以这里特意说明。
获取镜像 docker pull [options] [docker_registry_address[:port]/]repository[:tag] 其中：
docker_registry_address：Docker镜像仓库地址，格式一般为domain/IP[:port]。如果不给出，默认为Docker Hub repository：镜像名称，如ubuntu tag：指出镜像的版本，例如ubuntu:18.04，或者ubuntu:latest 例子：
$ docker pull ubuntu:18.</description></item><item><title>Ubuntu 18.04.3 各类代理配置</title><link>https://www.libre.fun/posts/vmware-ubuntu-proxy-configure/</link><pubDate>Tue, 15 Oct 2019 16:54:57 +0800</pubDate><guid>https://www.libre.fun/posts/vmware-ubuntu-proxy-configure/</guid><description>本文主要阐述在Ubuntu系统中为一些软件配置代理的方法，包括APT、Snap、Git、Bash命令行以及Ubuntu系统层面的HTTP代理。
准备工作 实验环境 本文中，笔者在VMware虚拟机中安装了Ubuntu系统，网络连接使用NAT模式。就代理的配置方式而言，无论虚拟机还是物理机都是通用的，区别只在于代理IP有所不同。在物理机上配置代理，只需要知道代理软件的IP（记作PROXY_IP）和端口（本文中默认使用1080）。
虚拟机使用NAT模式连接网络 如果你是在虚拟机中安装了Ubuntu系统，则需要确认其网络访问方式为NAT。打开VMware，右键点击左侧「库」面板中安装好的虚拟机，进入「网络适配器」查看网络连接模式，将其设置为「NAT模式」，如下图所示
代理工具的准备 由于众所周知的原因，必须借助某些代理软件才能够实现对外网的流畅访问。
在SS或者SSR中，需要打开“允许来自局域网的连接”(SSR-windows 4.9.2)或者“允许其他设备连入”(SS-windows 4.1.7)等类似的选项。该选项的名称可能会根据代理软件版本的不同而有细微的差别。
在宿主机上安装XShell （可选） XShell是一个用于SSH连接到主机的工具，这里推荐安装和使用。如果没有使用过这类工具的用户可以略过。
确认代理IP地址 在虚拟机方案中，通常是宿主机上运行代理软件，然后配置虚拟机Ubuntu系统的代理，从而使Ubuntu正常访问外网。此时则需要查看宿主机的IP地址。
以Windows为例，按下「Win+R」，输入cmd并按下回车，打开Windows命令提示符。
输入ipconfig，在「以太网适配器 VMware Network Adapter VMnet8」中查看IPv4地址，通常以172.16/17/18或者192.168开头。
VMware Network Adapter VMnet8 是VMware中使用NAT模式的虚拟机专用的网络适配器。
将该IP地址记为PROXY_IP，即我们需要的代理IP地址。后文中将始终使用PROXY_IP。读者在实践时需要替换为自己查看到的IP地址。
确认代理端口号 一般来讲，如果没有做过更改，SS和SSR使用的代理端口号都是1080。所以本文的命令中都会使用1080这个端口号。
确认系统权限 本文中使用的部分命令需要root权限，如果在root账户下，则可以直接执行命令；如果是在普通账户下，需要在命令前加上sudo关键字。
APT代理配置 参考：How to Set the Proxy for APT on Ubuntu 18.04
APT是Ubuntu系统内常用的软件包管理器，为APT配置代理之后能够保证一些软件可以正常安装，安装速度通常也会有一定的提升。
给APT配置代理的步骤如下：
$ sudo apt install vim # 该命令是为了安装Vim编辑器，Ubuntu不自带Vim；如果已安装，则可以忽略这一条 $ sudo vim /etc/apt/apt.conf.d/proxy.conf # 此时会创建并打开一个名为proxy.conf的文件，按下I进入编辑模式，输入以下几行 Acquire { HTTP::proxy &amp;#34;http://PROXY_IP:1080&amp;#34;; HTTPS::proxy &amp;#34;http://PROXY_IP:1080&amp;#34;; } # 输入后按下Esc，然后输入:wq，按下回车即可保存退出 打开代理软件（SS或者SSR）的流量监控，使用apt-get install命令安装任意一个包，查看下载速度并和宿主机上的流量监控数据进行对照，如果速度接近，即说明代理配置成功。</description></item><item><title>CentOS 7.6 Minimal Installation 后无法连接网络</title><link>https://www.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/</link><pubDate>Sat, 05 Oct 2019 12:53:00 +0800</pubDate><guid>https://www.libre.fun/posts/fix-network-connection-of-centos-with-mininal-installation/</guid><description>问题原因 在安装CentOS 7.6系统时，图形安装界面的部分有一个配置网络的选项，进去之后可以开启网卡，而Minimal Installation默认是不开启网卡的，因此如果在安装系统时由于疏忽忘记打开网卡，进入系统之后会发现无法联网，所有和网络有关的操作都会报错。
解决方法 首先通过命令nmcli d查看网卡启用状态：
[libre@localhost ~]$ nmcli d DEVICE TYPE STATE CONNECTION ens33 ethernet disconnected -- lo loopback unmanaged -- 发现网卡的确是未启用。然后编辑文件/etc/sysconfig/network-scripts/ifcfg-ens&amp;lt;num&amp;gt;，此处的&amp;lt;num&amp;gt;在每台机器可能不一样，使用Tab自动补全即可。
将该文件最后一行的ONBOOT=NO改为ONBOOT=YES，然后保存退出，再通过以下命令重启网络：
service network restart 此时再查看网卡状态：
[libre@localhost ~]$ nmcli d DEVICE TYPE STATE CONNECTION ens33 ethernet connected ens33 lo loopback unmanaged -- 搞定。</description></item></channel></rss>