<!doctype html><html><head><title>Docker 入门：镜像 - Libre's Blog</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link rel=stylesheet href=https://www.libre.fun/scss/journal.min.8650853483769a2c86962bebf88e58771fef8dc8b1690fe91be762e7a85085f6.css integrity="sha256-hlCFNIN2miyGlivr+I5Ydx/vjcixaQ/pG+di56hQhfY=" media=screen><script src=https://www.libre.fun//js/loadCSS.js></script><script src=https://www.libre.fun//js/table.js></script><script src=https://www.libre.fun//js/toc.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=https://www.libre.fun/><div class=nav-title>Libre's Blog</div><div class=nav-subtitle>理想是，以代码安身，以文字立命</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>文章</a>
<a class="a-block nav-link-item false" href=/tags>标签</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a><br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> and <a href=https://pages.github.com/ target=_blank>Github Pages</a><br><br>&copy;
Libre. 本站遵循 CC-BY-NC 4.0 协议</div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e9%95%9c%e5%83%8f%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 v-on:click=closeDrawer id=镜像的基本原理-nav>镜像的基本原理</a></li></ul></ul><ul><ul><li><a href=#%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93%e7%9a%84%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5 v-on:click=closeDrawer id=镜像仓库的相关概念-nav>镜像仓库的相关概念</a></li></ul></ul><ul><ul><li><a href=#%e8%8e%b7%e5%8f%96%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=获取镜像-nav>获取镜像</a></li></ul></ul><ul><ul><li><a href=#%e9%95%9c%e5%83%8f%e8%bf%90%e8%a1%8c v-on:click=closeDrawer id=镜像运行-nav>镜像运行</a></li></ul></ul><ul><ul><li><a href=#%e6%9f%a5%e7%9c%8b%e6%9c%ac%e5%9c%b0%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=查看本地镜像-nav>查看本地镜像</a></li></ul></ul><ul><ul><ul><li><a href=#%e6%97%a0%e5%8f%82%e6%95%b0 v-on:click=closeDrawer id=无参数-nav>无参数</a></li></ul></ul></ul><ul><ul><ul><li><a href=#-a%e5%88%97%e5%87%ba%e6%89%80%e6%9c%89%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=-a列出所有镜像-nav>-a：列出所有镜像</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e5%88%97%e5%87%ba%e9%83%a8%e5%88%86%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=列出部分镜像-nav>列出部分镜像</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e5%ae%9a%e5%88%b6%e8%be%93%e5%87%ba%e6%a0%bc%e5%bc%8f v-on:click=closeDrawer id=定制输出格式-nav>定制输出格式</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e6%9f%a5%e7%9c%8b%e9%95%9c%e5%83%8f%e4%bd%93%e7%a7%af v-on:click=closeDrawer id=查看镜像体积-nav>查看镜像体积</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e8%99%9a%e6%82%ac%e9%95%9c%e5%83%8fdangling-image v-on:click=closeDrawer id=虚悬镜像dangling-image-nav>虚悬镜像(dangling image)</a></li></ul></ul></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>文章</a>
<a class="a-block drawer-menu-item false" href=/tags>标签</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e9%95%9c%e5%83%8f%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 v-on:click=closeDrawer id=镜像的基本原理-nav>镜像的基本原理</a></li></ul></ul><ul><ul><li><a href=#%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93%e7%9a%84%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5 v-on:click=closeDrawer id=镜像仓库的相关概念-nav>镜像仓库的相关概念</a></li></ul></ul><ul><ul><li><a href=#%e8%8e%b7%e5%8f%96%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=获取镜像-nav>获取镜像</a></li></ul></ul><ul><ul><li><a href=#%e9%95%9c%e5%83%8f%e8%bf%90%e8%a1%8c v-on:click=closeDrawer id=镜像运行-nav>镜像运行</a></li></ul></ul><ul><ul><li><a href=#%e6%9f%a5%e7%9c%8b%e6%9c%ac%e5%9c%b0%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=查看本地镜像-nav>查看本地镜像</a></li></ul></ul><ul><ul><ul><li><a href=#%e6%97%a0%e5%8f%82%e6%95%b0 v-on:click=closeDrawer id=无参数-nav>无参数</a></li></ul></ul></ul><ul><ul><ul><li><a href=#-a%e5%88%97%e5%87%ba%e6%89%80%e6%9c%89%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=-a列出所有镜像-nav>-a：列出所有镜像</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e5%88%97%e5%87%ba%e9%83%a8%e5%88%86%e9%95%9c%e5%83%8f v-on:click=closeDrawer id=列出部分镜像-nav>列出部分镜像</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e5%ae%9a%e5%88%b6%e8%be%93%e5%87%ba%e6%a0%bc%e5%bc%8f v-on:click=closeDrawer id=定制输出格式-nav>定制输出格式</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e6%9f%a5%e7%9c%8b%e9%95%9c%e5%83%8f%e4%bd%93%e7%a7%af v-on:click=closeDrawer id=查看镜像体积-nav>查看镜像体积</a></li></ul></ul></ul><ul><ul><ul><li><a href=#%e8%99%9a%e6%82%ac%e9%95%9c%e5%83%8fdangling-image v-on:click=closeDrawer id=虚悬镜像dangling-image-nav>虚悬镜像(dangling image)</a></li></ul></ul></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=https://www.libre.fun/>Libre's Blog</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://www.libre.fun/><div class=single-column-header-title>Libre's Blog</div><div class=single-column-header-subtitle>理想是，以代码安身，以文字立命</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image:url('/')"><div class=post-title>Docker 入门：镜像<div class=post-meta><time itemprop=datePublished>2019/10/28 10:58</time>
<i class=material-icons>label</i>
<a href=/tags/docker>Docker</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body><blockquote><p>参考：<a href=https://yeasy.gitbooks.io/docker_practice/image/>Docker — 从入门到实践</a></p></blockquote><h2 id=镜像的基本原理>镜像的基本原理</h2><p>OS分为内核和用户空间。对于Linux而言，内核启动后， 会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p>Docker中的镜像利用Union FS技术，被设计为分层存储的架构，由多层文件系统联合组成。</p><p>镜像在构建时，会一层层构建，前一层是后一层的基础。 每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>分层存储的特征使得镜像的复用、定制变的更为容易。可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h2 id=镜像仓库的相关概念>镜像仓库的相关概念</h2><p>这里解释一下Docker镜像仓库相关的概念：</p><p>首先，读者应该知道Linux系统中有软件源的概念，一个软件源提供了若干软件的下载、安装与更新。例如，Ubuntu系统中通过<code>apt install</code>或者<code>apt-get install</code>命令从预先配置的软件源中下载和安装软件，CentOS也有类似的<code>yum install</code>等。</p><p>在Docker的世界中，这样的「软件源」被称为<strong>registry</strong>。registry用以保存Docker镜像，其中还包括镜像层次结构和关于镜像的元数据等。由Docker官方维护的registry被称为Docker Hub，用户也可以在自己的服务器上搭建私有的registry。</p><p>Docker Hub并不是只有Docker官方才可以提供镜像，它类似Github，任何用户都可以创建账号，向Docker Hub上传自己制作的镜像。</p><p>对于Docker Hub中存储的镜像，可以通过<code>[username/]repository:tag</code>来唯一指定。</p><ul><li>如果不提供<code>username</code>，则会指向Docker官方维护的镜像库，即<code>library</code>；如果提供了<code>username</code>，则指向的是该用户的镜像库（相当于账户）</li><li><code>repository</code>表示的是具有某个功能的Docker镜像的所有迭代版本构成的镜像组，例如<code>ubuntu</code>，其含义是包括Ubuntu 18.04、Ubuntu 16.04、Ubuntu 14.04等一系列镜像在内的镜像组</li><li><code>tag</code>用于指出<code>repository</code>中具体的某个镜像，例如<code>ubuntu:latest</code>，意为指定该镜像库中最新版的Ubuntu镜像；再例如<code>ubuntu:16.04</code>，意为指定版本号为16.04的Ubuntu镜像。</li></ul><blockquote class="my-alert my-alert-note"><p>但是对于一条<code>docker pull ubuntu</code>命令来说，并不是拉取了整个镜像组，而是会使用一个默认的<code>tag</code>，即<code>latest</code></p></blockquote><blockquote class="my-alert my-alert-warning"><p><p>不要混淆镜像库和镜像组的概念：</p><p>镜像库：默认为<code>library</code>或由<code>username</code>指定，是Docker官方或某用户提供的若干（不一定相关的）镜像组的集合；</p><p>镜像组：由<code>repository</code>，一般某个特定功能的镜像的若干迭代版本组成，每个迭代版本通常可以由一个标签指定，如上面举的<code>ubuntu</code>的例子；</p><p>因为<code>library</code>和<code>repository</code>在中文里都可以翻译为“库”，个人在看一些教程或书的时候也稍微混了一下，所以这里特意说明。</p></p></blockquote><h2 id=获取镜像>获取镜像</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker pull <span style=color:#f92672>[</span>options<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>docker_registry_address<span style=color:#f92672>[</span>:port<span style=color:#f92672>]</span>/<span style=color:#f92672>]</span>repository<span style=color:#f92672>[</span>:tag<span style=color:#f92672>]</span>
</code></pre></div><p>其中：</p><ul><li>docker_registry_address：Docker镜像仓库地址，格式一般为<code>domain/IP[:port]</code>。如果不给出，默认为Docker Hub</li><li>repository：镜像名称，如<code>ubuntu</code></li><li>tag：指出镜像的版本，例如<code>ubuntu:18.04</code>，或者<code>ubuntu:latest</code></li></ul><p>例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker pull ubuntu:18.04
latest: Pulling from library/ubuntu
22e816666fd6: Pull complete 
079b6d2a1e53: Pull complete 
11048ebae908: Pull complete 
c58094023a2e: Pull complete 
Digest: sha256:a7b8b7b33e44b123d7f997bd4d3d0a59fafc63e203d17efedf09ff3f6f516152
Status: Downloaded newer image <span style=color:#66d9ef>for</span> ubuntu:latest
</code></pre></div><p>上面的输出体现了分层存储的概念，镜像由多层存储构成，因此下载的时候也是一层一层地下载，这样也方便了本地镜像的复用，减少存储消耗。下载过程中给出了每一层的ID的前12位，该ID随着镜像的更新可能会有所变化；下载结束后，会给出该镜像完整的SHA256摘要，用以确认下载的一致性。</p><h2 id=镜像运行>镜像运行</h2><p>下面的命令给出了运行镜像的一个例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run -it --rm ubuntu:18.04 bash
root@7ca7d3899f54:/# cat /etc/os-release
NAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Ubuntu&#34;</span>
VERSION<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;18.04.3 LTS (Bionic Beaver)&#34;</span>
<span style=color:#75715e># 略去一些输出</span>
</code></pre></div><p><code>docker run</code>命令用于运行容器，这里涉及到的参数有：</p><ul><li><p><code>-it</code>：<code>-i</code>和<code>-t</code>参数的合并形式，前者表示进行交互式操作，后者表示启动一个伪终端。
如果加<code>-t</code>不加<code>-i</code>，则会显示<strong>伪终端</strong>，即命令行提示符，但无法输入命令与容器交互；如果加<code>-t</code>不加<code>-i</code>，则可以输入命令并执行，但不会显示伪终端，即没有命令行提示符。</p></li><li><p><code>--rm</code>：表示在容器退出后删除，这里因为仅是试运行，因此指定退出后删除，避免浪费空间</p></li><li><p><code>ubuntu:18.04</code>：指出要加载的镜像</p></li><li><p><code>bash</code>：启动容器后执行的命令，因为我们想要一个交互式Shell，因此使用<code>bash</code>·</p></li></ul><p>进入容器后默认是以<code>root</code>身份，此时可以像在常规Ubuntu系统中那样执行Shell命令，这里我们查看了一下系统信息。</p><p>最后可以通过按下<code>Ctrl+D</code>（退出当前会话）或输入<code>exit</code>退出容器。</p><blockquote class="my-alert my-alert-note"><p>事实上，此时按下 <code>Ctrl+D</code> 或输入<code>exit</code>是退出了<code>bash</code>，并不等同于直接退出容器。真正导致容器退出的原因是该容器的主进程，即<code>bash</code>退出了，主进程退出了，容器再无存在的必要，因此也随之退出了。</p></blockquote><h2 id=查看本地镜像>查看本地镜像</h2><p><code>docker image ls</code>命令用于列出已下载的镜像，并且提供了很多参数来定制输出。</p><h3 id=无参数>无参数</h3><p>不带参数的<code>docker image ls</code>命令会列出本地所有<strong>顶层</strong>镜像的信息，包括仓库名、标签、镜像ID、创建时间和占用的空间。</p><blockquote><p>与顶层镜像概念相对应的是中间层镜像，下文会提及</p></blockquote><p>镜像ID是一个镜像唯一的标识，同一个镜像有可能对应多个标签。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              18.04               cf0f3ca922e0        <span style=color:#ae81ff>9</span> days ago          64.2MB
ubuntu              latest              cf0f3ca922e0        <span style=color:#ae81ff>9</span> days ago          64.2MB
</code></pre></div><p>因为本文写作时，Docker官方镜像仓库中Ubuntu的最新版（latest）正是18.04，因此二者虽然标签不同，但是ID相同，对应的是同一个镜像。</p><h3 id=-a列出所有镜像><code>-a</code>：列出所有镜像</h3><p>相比于不带参数，带上<code>-a</code>参数会列出所有的<strong>中间层镜像</strong>，这些中间层镜像通常没有标签，是其他顶层镜像的依赖项，因此不要轻易删除。</p><h3 id=列出部分镜像>列出部分镜像</h3><ul><li><code>docker image ls ubuntu</code>：根据镜像组名列出镜像</li><li><code>docker image ls ubuntu:18.04</code>：列出某个特定的镜像</li><li><code>-f</code>/<code>--filter</code>：<code>docker image ls</code>支持过滤器，加上<code>-f</code>或者<code>--filter</code>，随后提供条件即可，例如：<ul><li><code>docker image ls -f since=ubuntu:latest</code>可以显示本地在<code>ubuntu:latest</code>之后拉取或者构建的镜像</li><li>同理，将<code>since</code>替换成<code>before</code>可以查看在某镜像之前拉取、构建的镜像</li><li>如果构建镜像时定义了<code>LABEL</code>，还可以使用类似<code>docker image ls -f label=xxx</code>来过滤</li></ul></li></ul><h3 id=定制输出格式>定制输出格式</h3><p><code>docker image ls</code>可以利用Go的模板语法来定制输出格式，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker image ls --format <span style=color:#e6db74>&#34;{{.ID}}: {{.Repository}}&#34;</span>
540a289bab6c: nginx
cf0f3ca922e0: ubuntu
cf0f3ca922e0: ubuntu
</code></pre></div><p>这样就可以只输出镜像的ID和镜像组名。值得一提的是，有时候为了批量删除镜像，通常会先用某种规则过滤出一批镜像ID，然后将输出作为参数传递给<code>docker image rm</code>来删除指定镜像，这种情况下可以使用<code>--format "{{.ID}}"</code>，也可以简单地使用<code>-q</code>参数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker image ls -q
540a289bab6c
cf0f3ca922e0
cf0f3ca922e0
</code></pre></div><h3 id=查看镜像体积>查看镜像体积</h3><p>在上面的<code>docker image ls</code>无参数的示例中，我们可以看到本地每个镜像的体积（Size）。但实际上，这里有两点需要注意：</p><ol><li>该命令列出的每个镜像的体积与Docker Hub内对应镜像所显示的体积会有不同，通常比Docker Hub的更大。这是因为Docker Hub中显示的是压缩过的体积，方便网络传输，而本地的Size则是该镜像的完整体积。</li><li>本地所有镜像的Size之和并不等于这些镜像实际占用的存储空间，因为不同镜像之间可能会复用一些中间层的镜像。</li></ol><p>要查看镜像实际占用的空间，可以使用<code>docker system df</code>命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker system df
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              <span style=color:#ae81ff>2</span>                   <span style=color:#ae81ff>0</span>                   190.4MB             190.4MB <span style=color:#f92672>(</span>100%<span style=color:#f92672>)</span>
Containers          <span style=color:#ae81ff>0</span>                   <span style=color:#ae81ff>0</span>                   0B                  0B
Local Volumes       <span style=color:#ae81ff>0</span>                   <span style=color:#ae81ff>0</span>                   0B                  0B
Build Cache         <span style=color:#ae81ff>0</span>                   <span style=color:#ae81ff>0</span>                   0B                  0B
</code></pre></div><h3 id=虚悬镜像dangling-image>虚悬镜像(dangling image)</h3><p>在使用Docker一段时间后，使用<code>docker image ls</code>查看镜像列表时，可能会出现<code>REPOSITORY</code>和<code>TAG</code>均为<code>&lt;none></code>的镜像，但是仍具有ID。</p><p>这类镜像出现的原因是，随着镜像组的维护，新版本的镜像被发布，旧镜像的镜像名被转移到了新镜像的身上。例如<code>ubuntu:18.04</code>，可能官方给其打了一个补丁后重新构建了镜像，但仍旧使用<code>ubuntu:18.04</code>这个镜像名。虽然镜像名保持了旧的名称，但由于内容发生了变化，新镜像的ID也发生了变化。此时，旧的镜像的镜像名被“剥夺”，成为了所谓的“虚悬镜像”。</p><p>使用<code>docker image ls -f dangling=true</code>可以专门查看此类镜像。</p></div></div><nav class=post-pagination><div class=newer-posts>新文 :<br><a href=https://www.libre.fun/posts/setup-startup-in-wsl/>WSL 设置开机启动项</a></div><div class=older-posts>旧文 :<br><a href=https://www.libre.fun/posts/vmware-ubuntu-proxy-configure/>Ubuntu 18.04.3 各类代理配置</a></div></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://amazingrise.net>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a><br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> and <a href=https://pages.github.com/ target=_blank>Github Pages</a><br><br>&copy;
Libre. 本站遵循 CC-BY-NC 4.0 协议</div></div><script src=https://www.libre.fun//js/journal.js></script></body></html>